//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t _qm__qm_0CReleaseAllScratchMemoryUponDestruction__QAE_PAVCScratchMemoryAllocator___Z(int32_t a1, int32_t a2);
int32_t _qm__qm_0CScratchMemoryAllocator__QAE_XZ(int32_t a1);
int32_t _qm__qm_1CReleaseAllScratchMemoryUponDestruction__QAE_XZ(int32_t a1);
void _qm__qm_1CScratchMemoryAllocator__QAE_XZ(void);
int32_t _qm_Alloc_CScratchMemoryAllocator__QAEPAXI_Z(int32_t a1, int32_t a2);
int32_t _qm_GetASN1Module_CXo__QAEPAUtagASN1module_t__XZ(int32_t a1);
int32_t _qm_GetTitleGameRegion_CXo__QAEKXZ(int32_t a1);
int32_t _qm_GetTitleId_CXo__QAEKXZ(int32_t a1);
int32_t _qm_GetTitleVersion_CXo__QAEKXZ(int32_t a1);
int32_t _qm_GetXoPtr_CScratchMemoryAllocator__QAEPAVCXo__XZ(int32_t a1);
int32_t _qm_KerbAddClientVersionPreAuth__YGJPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _qm_KerbAddCompoundIdentityPreAuth__YGJPAVCScratchMemoryAllocator__PAUXKERB_TGT_CONTEXT__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_KerbAddEchoPreAuth__YGJPAVCScratchMemoryAllocator__KPAEPAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t a2, char * a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7);
int32_t _qm_KerbAddPacRequestPreAuth__YGJPAVCScratchMemoryAllocator__HPAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t _qm_KerbAddPrePreAuth__YGJPAVCScratchMemoryAllocator__PADPAUKERB_ENCRYPTION_KEY__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, char * a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_KerbAddTimestampPreAuth__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTION_KEY__PAT_LARGE_INTEGER__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _qm_KerbAddXboxServiceRequestPreAuth__YGJPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__PBUXKERB_TGT_CONTEXT__KPBUXKERB_SERVICE_CONTEXT__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t a2);
int32_t _qm_KerbAllocateEncryptionBuffer__YGJPAVCScratchMemoryAllocator__KKPAKPAPAE_Z(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5);
int32_t _qm_KerbAllocateEncryptionBufferWrapper__YGJPAVCScratchMemoryAllocator__KKPAKPAPAE_Z(int32_t a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t _qm_KerbComputeCompoundIdentityKey__YGXPBUKERB_ENCRYPTION_KEY__PBUXKERB_TGT_CONTEXT__PAE_Z(int32_t a1);
int32_t _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(int32_t a1);
int32_t _qm_KerbComputeRequestBodyChecksum__YGJPAVCScratchMemoryAllocator__PAUKERB_KDC_REQUEST_BODY__PAUKERB_CHECKSUM___Z(int32_t a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t _qm_KerbConstructPrincipalName__YGJPAVCScratchMemoryAllocator__PAUKERB_PRINCIPAL_NAME__KPAD2_Z(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z(int32_t * a1, int16_t * a2, int32_t a3);
int32_t _qm_KerbConvertLargeIntToGeneralizedTime__YGXPAUtagASN1generalizedtime_t__PAJPAT_LARGE_INTEGER___Z(int16_t * a1, int32_t * a2, int32_t * a3);
int32_t _qm_KerbConvertUlongToFlagUlong__YGKK_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_KerbCreateApRequest__YGJPAVCScratchMemoryAllocator__PAD1PBUKERB_ENCRYPTION_KEY__KPAT_LARGE_INTEGER__PBUKERB_TICKET__KPBUKERB_CHECKSUM__EPAKPAPAE_Z(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, char * a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t * a12, int32_t a13, int32_t a14, int32_t a15);
int32_t _qm_KerbCreateAuthenticator__YGJPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KKPAT_LARGE_INTEGER__PAD3PBUKERB_CHECKSUM__EPAUKERB_ENCRYPTED_DATA___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t * a8, uint32_t a9, int32_t a10);
int32_t _qm_KerbCreateKeyFromBuffer__YGXPAUKERB_ENCRYPTION_KEY__PAEKK_Z(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t _qm_KerbDecryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__PAUKERB_ENCRYPTION_KEY__KPAKPAE_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_KerbEncryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__KPAEKKPBUKERB_ENCRYPTION_KEY___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _qm_KerbFindPreAuthDataEntry__YGPAUKERB_PA_DATA__KPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t * a2);
int32_t _qm_KerbGetCurrentTime__YGXPAT_LARGE_INTEGER___Z(int32_t a1, int32_t a2);
int32_t _qm_KerbGetEncryptionOverhead__YGKXZ(void);
int32_t _qm_KerbInitAsn__YGJPAVCScratchMemoryAllocator__PAPAUASN1encoding_s__PAPAUASN1decoding_s___Z(int32_t a1, int32_t a2, int32_t a3);
int32_t _qm_KerbMapKerbError__YGJJ_Z(int32_t a1);
int32_t _qm_KerbMultiStringToPrincipalName__YGJPAVCScratchMemoryAllocator__PADPAUKERB_PRINCIPAL_NAME___Z(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5);
int32_t _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5, int32_t a6, int32_t a7, int32_t a8);
int32_t _qm_KerbPrincipalNameToMultiString__YGJPAUKERB_PRINCIPAL_NAME__KPAD_Z(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
void _qm_KerbTermAsn__YGXPAUASN1encoding_s__PAUASN1decoding_s___Z(int32_t a1);
int32_t _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5, int32_t a6);
int32_t _qm_KerbUnpackKdcReplyBody__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__PAUKERB_ENCRYPTION_KEY__KPAPAUKERB_ENCRYPTED_KDC_REPLY___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5);
void _qm_KerbUpdateCurrentTime__YGXT_LARGE_INTEGER___Z(void);
int32_t _qm_KerbVerifyAccountCreationPreAuth__YGJPAVCScratchMemoryAllocator__PAUKERB_PA_DATA__PBUKERB_ENCRYPTION_KEY__PAUXKERB_TGT_CONTEXT___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t _qm_KerbVerifyServiceAddressPreAuth__YGJPAVCScratchMemoryAllocator__PAUKERB_PA_DATA__PBUKERB_ENCRYPTION_KEY__PAUXKERB_SERVICE_CONTEXT__PAU_XKERB_PA_XBOX_SERVICE_ADDRESS___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_md5Hmac__YGEPBEK0K0KPAE_Z(char * a1, uint32_t a2);
int32_t _qm_Pop_CScratchMemoryAllocator__QAEXXZ(int32_t a1);
int32_t _qm_PreserveThisMemoryHelper_CReleaseAllScratchMemoryUponDestruction__QAEPAXPAPAXPAXK_Z(int32_t * a1, char * a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t _qm_Push_CScratchMemoryAllocator__QAEXXZ(int32_t a1);
int32_t _qm_rc4HmacDecrypt__YGJPBEKKPAEK1PAK_Z(int32_t a1, int32_t a2, int32_t a3, char * a4, uint32_t a5, int32_t a6, int32_t * a7);
int32_t _qm_rc4HmacEncrypt__YGJPAVCScratchMemoryAllocator__PBEKKPAEK2PAK_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _qm_ScratchMemoryAllocator_CReleaseAllScratchMemoryUponDestruction__QAEPAVCScratchMemoryAllocator__XZ(int32_t a1);
int32_t _qm_ScratchMemoryInitializeHelper_CScratchMemoryAllocator__QAEPAXPAXI0IPAVCXo___Z(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t _qm_TempBuffer_CScratchMemoryAllocator__QAEPAXXZ(int32_t a1);
int32_t _qm_TempBufferSize_CScratchMemoryAllocator__QAEKXZ(int32_t a1);
int32_t _qm_XkerbBuildApRequest_CXo__IAEJPAUXKERB_SERVICE_CONTEXT__PAT_LARGE_INTEGER__PAEI2PAI_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_XkerbBuildAsRequest_CXo__IAEJHPAUXONLINEP_USER__PAEPAKPAUXKERB_TGT_CONTEXT___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_XkerbBuildTgsRequest_CXo__IAEJPAUXKERB_TGT_CONTEXT__PAEPAKPAUXKERB_SERVICE_CONTEXT___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_XkerbVerifyApReply_CXo__IAEJPAUXKERB_SERVICE_CONTEXT__PAT_LARGE_INTEGER__IPAEI2I_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_XkerbVerifyAsReply_CXo__IAEJPAEKPAUXKERB_TGT_CONTEXT___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_XkerbVerifyTgsReply_CXo__IAEJPAUXKERB_TGT_CONTEXT__PAEKPAUXKERB_SERVICE_CONTEXT___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _qm_XNetRandom_CXNet__QAEHPAEI_Z(void);
int32_t _qm_XNetUpdateConfigParams_CXNet__QAEHHH_Z(void);
int32_t function_1090(int32_t a1);
int32_t function_109e(void);
int32_t function_10a8(int32_t result, int32_t a2);
void function_11f5(int32_t a1);
void function_1207(void);
int32_t function_138d(int32_t a1, int32_t a2);
int32_t function_155f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_17cb(void);
int32_t function_17dd(void);
int32_t function_17f2(void);
int32_t function_1807(void);
int32_t function_1810(void);
int32_t function_1834(void);
int32_t function_1846(void);
int32_t function_184f(int32_t a1, int32_t a2);
int32_t function_1a71(int32_t a1, int32_t a2);
int32_t function_1a9f(void);
int32_t function_1ab1(void);
int32_t function_1ac2(void);
void function_1af3(void);
int32_t function_30c6(void);
int32_t function_30d8(void);
int32_t function_30ea(void);
int32_t function_30f6(void);
int32_t function_32d8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3305(int32_t a1);
int32_t function_331d(void);
int32_t function_332c(void);
int32_t function_333b(void);
int32_t function_3347(void);
int32_t function_3354(void);
int32_t function_336f(void);
int32_t function_3370(int32_t a1);
int32_t function_37aa(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_37f3(int32_t a1);
int32_t function_3831(void);
int32_t function_3832(int32_t a1, int32_t a2);
int32_t function_3a60(void);
int32_t function_3a72(void);
int32_t function_3a89(void);
int32_t function_3a95(void);
int32_t function_3bf2(int32_t a1, int32_t a2);
int32_t function_3bff(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3d82(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3e02(int32_t a1);
int32_t function_3e31(int32_t a1, int32_t a2);
int32_t function_3e91(void);
int32_t function_402b(int32_t a1, int32_t a2);
int32_t function_4536(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_4751(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_476f(int32_t a1, int32_t a2);
int32_t function_47ae(void);
int32_t function_47c1(int32_t a1, int32_t a2);
int32_t function_4a2e(void);
int32_t function_4a3d(void);
int32_t function_4a46(void);
int32_t function_4a53(int32_t a1);
int32_t function_4a75(int32_t a1, int32_t a2);
void function_5517(void);
int32_t function_5519(int32_t a1, int32_t a2, int32_t a3);
int32_t function_55a0(void);
void function_5707(int32_t a1, int32_t a2);
void function_5f4b(void);
int32_t function_5f4d(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5fd4(void);
int32_t function_617f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
void function_62fe(void);
int32_t function_6300(int32_t a1, int32_t a2, int32_t a3);
int32_t function_6387(void);
void function_657b(int32_t a1);
void function_66fc(int32_t a1);
void function_672c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
void function_674a(int32_t a1);
void function_675c(int32_t a1, int32_t a2);
void function_67a1(int32_t a1);
int32_t function_6808(int32_t a1, int32_t a2);
void function_6b09(int32_t a1, int32_t a2);
void function_6c1d(void);
void function_6c26(void);
void function_6c7c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_6d4b(void);
void function_6d58(int32_t a1, int32_t a2, int32_t a3);
int32_t function_6e40(void);
void function_7062(int32_t a1, int32_t a2);
void function_7141(int32_t a1);
void function_7149(void);
void function_718b(int32_t a1, int32_t a2, int32_t a3);
int32_t function_739d(void);
void function_73aa(int32_t a1, int32_t a2, int32_t a3);
int32_t function_7492(void);
void function_7ae8(void);
int32_t function_7aea(int32_t a1, int32_t a2, int32_t a3);
int32_t function_7b6c(void);
void function_7de0(int32_t a1, int32_t a2);
void function_7e72(int32_t a1);
void function_7ea7(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
void function_7fe7(void);
int32_t function_7fe9(int32_t a1, int32_t a2, int32_t a3);
int32_t function_811f(int32_t a1);
void function_8381(int32_t a1);
int32_t unknown_1cc2(void);
int32_t unknown_1d90(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // ecx
int32_t g5 = 0; // edi
int32_t g6 = 0; // edx
int32_t g7 = 0; // esi
int32_t g8 = 0; // esp
int32_t g9 = 0xadc68; // 0x66fc
int32_t g10;
int32_t g11 = -0x2a696001;

// ------------------------ Functions -------------------------

// Address range: 0xafc - 0xb16
int32_t _qm_KerbCreateKeyFromBuffer__YGXPAUKERB_ENCRYPTION_KEY__PAEKK_Z(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = (int32_t)a1;
    *a1 = a4;
    *(int32_t *)(result + 4) = a3;
    *(int32_t *)(result + 8) = a2;
    return result;
}

// Address range: 0xbfa - 0xbfd
int32_t _qm_KerbGetEncryptionOverhead__YGKXZ(void) {
    // 0xbfa
    return 24;
}

// Address range: 0xc8b - 0xc96
int32_t _qm_KerbMapKerbError__YGJJ_Z(int32_t a1) {
    // 0xc8b
    return a1 | -0x50010000;
}

// Address range: 0xd31 - 0xd51
int32_t _qm_KerbFindPreAuthDataEntry__YGPAUKERB_PA_DATA__KPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    if (a2 == NULL) {
        // 0xd46
        return v1 != 0 ? v1 + 4 : 0;
    }
    while (true) {
        // 0xd37
        if (*(int32_t *)(v1 + 4) == a1) {
            // 0xd37
            // branch -> 0xd46
            // 0xd46
            return v1 != 0 ? v1 + 4 : 0;
        }
        int32_t v2 = *(int32_t *)v1;
        if (v2 == 0) {
            // break -> 0xd42
            break;
        }
        v1 = v2;
        // continue -> 0xd37
    }
    // 0xd42
    v1 = 0;
    // branch -> 0xd46
    // 0xd46
    return v1 != 0 ? v1 + 4 : 0;
}

// Address range: 0xe07 - 0xeba
int32_t _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z(int32_t * a1, int16_t * a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2;
    g2 = &v2;
    int16_t v3; // bp-20
    int32_t v4 = &v3;
    int32_t v5 = g7;
    int32_t v6 = g5;
    int32_t result = 0; // eax
    v3 = 0;
    *(int32_t *)(v4 + 4) = 0;
    *(int32_t *)(v4 + 8) = result;
    *(int16_t *)(v4 + 12) = (int16_t)result;
    int32_t v7 = (int32_t)a2;
    uint16_t v8 = v3;
    uint16_t v9 = *(int16_t *)v7;
    int32_t v10 = 6;
    // branch -> if_e2a_0_true
    while (v10 != 0 && ((int32_t)v8 - (int32_t)v9) % 0x10000 == 0) {
        // if_e2a_0_true
        v7 += 2;
        v8 = v3;
        v9 = *(int16_t *)v7;
        v10--;
        // continue -> if_e2a_0_true
    }
    // after_if_e2a_0
    if (((int32_t)v8 - (int32_t)v9) % 0x10000 == 0) {
        // 0xe4c
        result = v1;
        *a1 = 0;
        *(int32_t *)(result + 4) = 0;
        g5 = v6;
        g7 = v5;
        g2 = v2;
        return result;
    }
    // 0xe2f
    v3 = 1970;
    uint16_t v11 = *(int16_t *)v7;
    int32_t v12 = v7 + 2;
    g5 = v12;
    int32_t v13 = 6;
    // branch -> if_e47_0_true
    while (v13 != 0 && (1970 - (int32_t)v11) % 0x10000 == 0) {
        // if_e47_0_true
        v7 = v12;
        v11 = *(int16_t *)v7;
        v12 = v7 + 2;
        g5 = v12;
        v13--;
        // continue -> if_e47_0_true
    }
    // after_if_e47_0
    if ((1970 - (int32_t)v11) % 0x10000 != 0) {
        // 0xe58
        g7 = v1;
        v3 = *a2;
        abort();
        // UNREACHABLE
    }
    // 0xe4c
    result = v1;
    *a1 = 0;
    *(int32_t *)(result + 4) = 0;
    g5 = v6;
    g7 = v5;
    g2 = v2;
    return result;
}

// Address range: 0x1003 - 0x108f
int32_t _qm_KerbConvertLargeIntToGeneralizedTime__YGXPAUtagASN1generalizedtime_t__PAJPAT_LARGE_INTEGER___Z(int16_t * a1, int32_t * a2, int32_t * a3) {
    int32_t v1 = (int32_t)a3;
    int32_t v2;
    g2 = &v2;
    int32_t v3 = g7; // 0x1009
    int32_t v4 = (int32_t)a1;
    g7 = v4;
    int32_t v5 = 0; // eax
    *(int32_t *)a1 = 0;
    *(int32_t *)(v4 + 4) = v5;
    *(int32_t *)(v4 + 8) = v5;
    *(int16_t *)(v4 + 12) = (int16_t)v5;
    g5 = v1;
    if (*(int32_t *)(v1 + 4) != *a3) {
        // 0x103a
        abort();
        // UNREACHABLE
    }
    // 0x1021
    *(int16_t *)g7 = 1970;
    *(char *)(g7 + 2) = 1;
    *(char *)(g7 + 3) = 1;
    *a2 = 0;
    int32_t v6;
    function_10a8(v3, v6);
    g7 = v3;
    return (int32_t)a2;
}

// Address range: 0x1090 - 0x109d
int32_t function_1090(int32_t a1) {
    // 0x1090
    return function_109e();
}

// Address range: 0x109e - 0x10a7
int32_t function_109e(void) {
    int32_t result = *(int32_t *)(g2 + 12); // 0x109e
    *(int32_t *)result = g1;
    *(int32_t *)(g7 + 12) = 0;
    return result;
}

// Address range: 0x10a8 - 0x10b1
int32_t function_10a8(int32_t result, int32_t a2) {
    // 0x10a8
    int32_t v1;
    g5 = v1;
    *(char *)(g7 + 10) = 1;
    g2 = *(int32_t *)g2;
    return result;
}

// Address range: 0x11e5 - 0x11f4
void _qm_KerbTermAsn__YGXPAUASN1encoding_s__PAUASN1decoding_s___Z(int32_t a1) {
    // 0x11e5
    function_11f5(a1);
}

// Address range: 0x11f5 - 0x1206
void function_11f5(int32_t a1) {
    // 0x11f5
    function_1207();
}

// Address range: 0x1207 - 0x1209
void function_1207(void) {
    // 0x1207
    return;
}

// Address range: 0x12ab - 0x12ca
int32_t _qm_KerbConvertUlongToFlagUlong__YGKK_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x12ab
    int32_t v1;
    g2 = v1;
    int32_t v2;
    return 0x1000000 * v2 / 0x1000000;
}

// Address range: 0x1382 - 0x138c
int32_t _qm_KerbGetCurrentTime__YGXPAT_LARGE_INTEGER___Z(int32_t a1, int32_t a2) {
    // 0x1382
    g7 = a1;
    int32_t v1;
    return function_138d(a1, v1);
}

// Address range: 0x138d - 0x13cb
int32_t function_138d(int32_t a1, int32_t a2) {
    int32_t result2 = *(int32_t *)g7; // 0x138d
    int32_t v1 = *(int32_t *)(g7 + 4); // 0x1395
    int32_t v2;
    if (result2 == *(int32_t *)2760) {
        // 0x139a
        if (v1 == *(int32_t *)2764) {
            int32_t result = *(int32_t *)2768 + 10; // 0x13a2
            *(int32_t *)2768 = result;
            int32_t * v3 = (int32_t *)g7; // 0x13ae_0
            uint32_t v4 = *v3; // 0x13ae
            uint32_t v5 = v4 + result; // 0x13ae
            *v3 = v5;
            int32_t * v6 = (int32_t *)(g7 + 4); // 0x13b0_0
            *v6 = (int32_t)(v5 < v4) + *v6;
            // branch -> 0x13c8
            // 0x13c8
            g7 = v2;
            return result;
        }
    }
    // 0x13b6
    *(int32_t *)2768 = 0;
    *(int32_t *)2760 = result2;
    *(int32_t *)2764 = v1;
    // branch -> 0x13c8
    // 0x13c8
    g7 = v2;
    return result2;
}

// Address range: 0x148b - 0x149a
void _qm_KerbUpdateCurrentTime__YGXT_LARGE_INTEGER___Z(void) {
    // 0x148b
    abort();
    // UNREACHABLE
}

// Address range: 0x153f - 0x155e
int32_t _qm_KerbPrincipalNameToMultiString__YGJPAUKERB_PRINCIPAL_NAME__KPAD_Z(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1;
    g2 = &v1;
    g3 = a3;
    int32_t v2 = g7; // 0x154b
    g7 = (int32_t)a1;
    return function_155f(a3, a2, (int32_t)"%d", *a1, v2);
}

// Address range: 0x155f - 0x15d5
int32_t function_155f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x155f
    int32_t v1; // 0x15c4
    if (g1 > -1) {
        // 0x156f
        g4 = g3 + 1;
        int32_t v2 = g3; // 0x1576
        int32_t v3 = (int32_t)*(char *)v2 | g6 & -256; // 0x1574
        int32_t v4 = v3; // edx
        int32_t v5 = v2 + 1; // 0x1576
        // branch -> 0x1574
        while (v3 != 0) {
            // 0x1574
            v2 = v5;
            v3 = (int32_t)*(char *)v2 | v3 & -256;
            v4 = v3;
            v5 = v2 + 1;
            // continue -> 0x1574
        }
        int32_t v6 = g5; // bp+12
        int32_t v7 = v5; // edi
        int32_t v8 = *(int32_t *)(g7 + 4); // eax
        *(int32_t *)(g2 + 16) = *(int32_t *)(g2 + 12) + g3;
        int32_t v9 = v8;
        if (v9 == 0) {
            // 0x157b
            // branch -> 0x15c1
            // 0x15c1
            *(char *)v7 = 0;
            // branch -> 0x15c3
        } else {
            // branch -> 0x158d
            int32_t v10; // 0x159d
            while (true) {
                int32_t * v11 = (int32_t *)(v9 + 4); // 0x158d_0
                int32_t v12 = *v11; // 0x158d
                int32_t v13 = v12; // 0x1595
                int32_t v14 = (int32_t)*(char *)v13 | v4 & -256; // 0x1593
                int32_t v15 = v13 + 1; // 0x1595
                // branch -> 0x1593
                while (v14 != 0) {
                    // 0x1593
                    v13 = v15;
                    v14 = (int32_t)*(char *)v13 | v14 & -256;
                    v15 = v13 + 1;
                    // continue -> 0x1593
                }
                uint32_t v16 = v15 - (v12 + 1) + 1; // 0x159c
                g4 = v16;
                int32_t v17 = v7; // 0x159d
                v10 = v17 + v16;
                if (v10 + 1 > *(int32_t *)(g2 + 16)) {
                    // 0x15cd
                    *(int32_t *)(g2 - 4) = 60;
                    // branch -> 0x15c3
                    // 0x15c3
                    g5 = v6;
                    // branch -> 0x15c4
                    // 0x15c4
                    v1 = g2;
                    g3 = a5;
                    g2 = *(int32_t *)v1;
                    return *(int32_t *)(v1 - 4);
                }
                char * v18 = (char *)*v11;
                memcpy((char *)v17, v18, v16 / 4);
                g4 = (int32_t)memcpy((char *)v7, v18, v16 % 4);
                int32_t v19 = *(int32_t *)v8; // 0x15b9
                v8 = v19;
                v7 = v10;
                if (v19 == 0) {
                    // break -> 0x15c1
                    break;
                }
                v4 = v10;
                v9 = v19;
                // continue -> 0x158d
            }
            // 0x15c1
            *(char *)v10 = 0;
            // branch -> 0x15c3
        }
        // 0x15c3
        g5 = v6;
        // branch -> 0x15c4
    } else {
        // 0x1566
        *(int32_t *)(g2 - 4) = -0x3fffff66;
        // branch -> 0x15c4
    }
    // 0x15c4
    v1 = g2;
    g3 = a5;
    g2 = *(int32_t *)v1;
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x1747 - 0x17ca
int32_t _qm_md5Hmac__YGEPBEK0K0KPAE_Z(char * a1, uint32_t a2) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = a2; // edx
    if (a2 >= 65) {
        // 0x175a
        v2 = 64;
        // branch -> 0x175d
    }
    // 0x175d
    int32_t v3;
    memset((char *)&v3, 0, 16);
    memcpy((char *)&v3, a1, v2 / 4);
    memcpy((char *)&v3, a1, v2 % 4);
    int32_t v4;
    memset((char *)&v4, 0, 16);
    memcpy((char *)&v4, a1, v2 / 4);
    memcpy((char *)&v4, a1, v2 % 4);
    int32_t v5 = 0; // eax
    int32_t * v6 = (int32_t *)(g2 - 148); // 0x17a7_0
    *v6 = *v6 ^ 0x36363636;
    int32_t * v7 = (int32_t *)(g2 - 84 + v5); // 0x17b2_0
    *v7 = *v7 ^ 0x5c5c5c5c;
    int32_t v8 = v5 + 4; // 0x17ba
    v5 = v8;
    // branch -> 0x17a7
    while (v8 < 64) {
        // 0x17a7
        v6 = (int32_t *)(v8 - 148 + g2);
        *v6 = *v6 ^ 0x36363636;
        v7 = (int32_t *)(g2 - 84 + v5);
        *v7 = *v7 ^ 0x5c5c5c5c;
        v8 = v5 + 4;
        v5 = v8;
        // continue -> 0x17a7
    }
    // 0x17c2
    return function_17cb();
}

// Address range: 0x17cb - 0x17dc
int32_t function_17cb(void) {
    // 0x17cb
    return function_17dd();
}

// Address range: 0x17dd - 0x17f1
int32_t function_17dd(void) {
    // 0x17dd
    return function_17f2();
}

// Address range: 0x17f2 - 0x1806
int32_t function_17f2(void) {
    // 0x17f2
    return function_1807();
}

// Address range: 0x1807 - 0x180f
int32_t function_1807(void) {
    // 0x1807
    return function_1810();
}

// Address range: 0x1810 - 0x1833
int32_t function_1810(void) {
    int32_t v1 = g2; // 0x1813
    memcpy((char *)(v1 - 228), (char *)(v1 - 84), 16);
    int32_t v2 = g2; // 0x181e
    *(int32_t *)(v2 - 164) = *(int32_t *)(v2 + 72);
    *(int32_t *)(v2 - 160) = *(int32_t *)(v2 + 76);
    *(int32_t *)(v2 - 156) = *(int32_t *)(v2 + 80);
    *(int32_t *)(v2 - 152) = *(int32_t *)(v2 + 84);
    return function_1834();
}

// Address range: 0x1834 - 0x1845
int32_t function_1834(void) {
    // 0x1834
    return function_1846();
}

// Address range: 0x1846 - 0x184e
int32_t function_1846(void) {
    int32_t v1 = g2 - 20; // 0x1846
    g1 = v1;
    return function_184f(v1, 0);
}

// Address range: 0x184f - 0x1863
int32_t function_184f(int32_t a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(g2 + 124); // 0x184f
    *(int32_t *)v1 = *(int32_t *)(g2 + 72);
    *(int32_t *)(v1 + 4) = *(int32_t *)(g2 + 76);
    *(int32_t *)(v1 + 8) = *(int32_t *)(g2 + 80);
    *(int32_t *)(v1 + 12) = *(int32_t *)(g2 + 84);
    int32_t v2;
    g5 = v2;
    g7 = a1;
    g2 += 92;
    return g1 & -256 | 1;
}

// Address range: 0x1a18 - 0x1a70
int32_t _qm_rc4HmacDecrypt__YGJPBEKKPAEK1PAK_Z(int32_t a1, int32_t a2, int32_t a3, char * a4, uint32_t a5, int32_t a6, int32_t * a7) {
    int32_t v1;
    g2 = &v1;
    if (a5 <= 23) {
        // 0x1a27
        function_1af3();
        return -0x3fffff93;
    }
    // 0x1a31
    _qm_md5Hmac__YGEPBEK0K0KPAE_Z((char *)a1, a2);
    int32_t v2;
    memcpy((char *)&v2, a4, 6);
    *a7 = a5 - 24;
    return function_1a71(a6, (int32_t)a4 + 24);
}

// Address range: 0x1a71 - 0x1a9e
int32_t function_1a71(int32_t a1, int32_t a2) {
    // 0x1a71
    _qm_md5Hmac__YGEPBEK0K0KPAE_Z((char *)(g2 - 40), 16);
    return function_1a9f();
}

// Address range: 0x1a9f - 0x1ab0
int32_t function_1a9f(void) {
    // 0x1a9f
    return function_1ab1();
}

// Address range: 0x1ab1 - 0x1ac1
int32_t function_1ab1(void) {
    // 0x1ab1
    return function_1ac2();
}

// Address range: 0x1ac2 - 0x1af2
int32_t function_1ac2(void) {
    int32_t v1 = g5; // 0x1ad1
    int32_t v2 = g2 - 40; // 0x1ad2
    _qm_md5Hmac__YGEPBEK0K0KPAE_Z((char *)v2, v1);
    int32_t v3 = g2 - 56; // 0x1ae6
    int32_t v4 = g2 - 24; // 0x1ae6
    int32_t v5 = *(int32_t *)v4; // 0x1ae6
    int32_t v6 = *(int32_t *)v3; // 0x1ae6
    int32_t v7 = 3; // 0x1ae6
    // branch -> if_1ae6_0_true
    while (v7 != 0 && v5 == v6) {
        // if_1ae6_0_true
        g4 = v7;
        v3 += 4;
        v4 += 4;
        v5 = *(int32_t *)v4;
        v6 = *(int32_t *)v3;
        v7--;
        // continue -> if_1ae6_0_true
    }
    // after_if_1ae6_0
    g5 = v2;
    g7 = v1;
    return v5 == v6 ? 0 : -0x3fffff93;
}

// Address range: 0x1af3 - 0x1af6
void function_1af3(void) {
    // 0x1af3
    return;
}

// Address range: 0x1cbd - 0x1cc1
int32_t _qm_XNetUpdateConfigParams_CXNet__QAEHHH_Z(void) {
    // 0x1cbd
    return unknown_1cc2();
}

// Address range: 0x1d8b - 0x1d8f
int32_t _qm_XNetRandom_CXNet__QAEHPAEI_Z(void) {
    // 0x1d8b
    return unknown_1d90();
}

// Address range: 0x1e42 - 0x1e47
int32_t _qm__qm_0CScratchMemoryAllocator__QAE_XZ(int32_t a1) {
    // 0x1e42
    *(int32_t *)g4 = 0;
    return g4;
}

// Address range: 0x1efb - 0x1f48
int32_t _qm_ScratchMemoryInitializeHelper_CScratchMemoryAllocator__QAEPAXPAXI0IPAVCXo___Z(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x1efb
    *(int32_t *)(g4 + 16) = 0;
    *(int32_t *)(g4 + 20) = 0;
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(g4 + 4) = a2 + v1;
    *(int32_t *)g4 = v1;
    *(int32_t *)(g4 + 8) = v1;
    memset(a1, 0, a2 / 4);
    memset(a1, 0, a2 % 4);
    *(int32_t *)(g4 + 12) = a3;
    if (a3 != 0) {
        // 0x1f37
        *(int32_t *)(g4 + 16) = a4;
        // branch -> 0x1f3d
    }
    // 0x1f3d
    *(int32_t *)(g4 + 56) = a5;
    return *(int32_t *)g4;
}

// Address range: 0x20a5 - 0x20a5
void _qm__qm_1CScratchMemoryAllocator__QAE_XZ(void) {
    // 0x20a5
    return;
}

// Address range: 0x215a - 0x215d
int32_t _qm_GetXoPtr_CScratchMemoryAllocator__QAEPAVCXo__XZ(int32_t a1) {
    // 0x215a
    return *(int32_t *)(g4 + 56);
}

// Address range: 0x2202 - 0x2205
int32_t _qm_TempBuffer_CScratchMemoryAllocator__QAEPAXXZ(int32_t a1) {
    // 0x2202
    return *(int32_t *)(g4 + 12);
}

// Address range: 0x22ac - 0x22af
int32_t _qm_TempBufferSize_CScratchMemoryAllocator__QAEKXZ(int32_t a1) {
    // 0x22ac
    return *(int32_t *)(g4 + 16);
}

// Address range: 0x235a - 0x2378
int32_t _qm_Alloc_CScratchMemoryAllocator__QAEPAXI_Z(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(g4 + 8); // 0x235e_0
    int32_t v2 = *v1; // 0x235e
    uint32_t v3 = v2 + (a1 + 3 & -4); // 0x2367
    *v1 = v3;
    int32_t result; // 0x2376_2
    if (v3 > *(int32_t *)(g4 + 4)) {
        // 0x2371
        *(int32_t *)(g4 + 8) = v2;
        result = 0;
        // branch -> 0x2376
    } else {
        // 0x235a
        result = v2;
        // branch -> 0x2376
    }
    // 0x2376
    return result;
}

// Address range: 0x2431 - 0x243e
int32_t _qm_Push_CScratchMemoryAllocator__QAEXXZ(int32_t a1) {
    int32_t result = *(int32_t *)(g4 + 20); // 0x2431
    *(int32_t *)(g4 + 24 + 4 * result) = *(int32_t *)(g4 + 8);
    int32_t * v1 = (int32_t *)(g4 + 20); // 0x243b_0
    *v1 = *v1 + 1;
    return result;
}

// Address range: 0x24df - 0x2505
int32_t _qm_Pop_CScratchMemoryAllocator__QAEXXZ(int32_t a1) {
    int32_t * v1 = (int32_t *)(g4 + 20); // 0x24e1_0
    *v1 = *v1 - 1;
    int32_t * v2 = (int32_t *)(g4 + 8); // 0x24e7_0
    int32_t v3 = *(int32_t *)(g4 + 24 + 4 * *(int32_t *)(g4 + 20)); // 0x24eb
    char * v4 = (char *)v3;
    int32_t v5 = *v2 - v3; // 0x24ef
    *v2 = v3;
    memset(v4, 0, v5 / 4);
    memset(v4, 0, v5 % 4);
    return 0;
}

// Address range: 0x25c5 - 0x25e2
int32_t _qm__qm_0CReleaseAllScratchMemoryUponDestruction__QAE_PAVCScratchMemoryAllocator___Z(int32_t a1, int32_t a2) {
    *(int32_t *)(g4 + 4) = 0;
    *(int32_t *)g4 = a1;
    int32_t v1 = *(int32_t *)(a1 + 8); // 0x25d5
    *(int32_t *)(a1 + 24 + 4 * *(int32_t *)(a1 + 20)) = v1;
    int32_t * v2 = (int32_t *)(a1 + 20); // 0x25dc_0
    *v2 = *v2 + 1;
    return g4;
}

// Address range: 0x26fa - 0x26fc
int32_t _qm_ScratchMemoryAllocator_CReleaseAllScratchMemoryUponDestruction__QAEPAVCScratchMemoryAllocator__XZ(int32_t a1) {
    // 0x26fa
    return *(int32_t *)g4;
}

// Address range: 0x27bf - 0x27ff
int32_t _qm_PreserveThisMemoryHelper_CReleaseAllScratchMemoryUponDestruction__QAEPAXPAPAXPAXK_Z(int32_t * a1, char * a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t result = (int32_t)a2;
    if (a2 == NULL) {
        // 0x27cb
        result = *(int32_t *)(*(int32_t *)g4 + 12);
        // branch -> 0x27d0
    }
    char * v1 = (char *)*a1;
    char * v2 = (char *)result;
    memcpy(v2, v1, a3 / 4);
    memcpy(v2, v1, a3 % 4);
    *(int32_t *)(g4 + 8) = (int32_t)a1;
    *(int32_t *)(g4 + 12) = a3;
    *(int32_t *)(g4 + 4) = result;
    return result;
}

// Address range: 0x2962 - 0x29cd
int32_t _qm__qm_1CReleaseAllScratchMemoryUponDestruction__QAE_XZ(int32_t a1) {
    int32_t v1 = *(int32_t *)g4; // 0x2964
    int32_t * v2 = (int32_t *)(v1 + 20); // 0x2966_0
    *v2 = *v2 - 1;
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x2969_0
    int32_t v4 = *(int32_t *)(v1 + 24 + 4 * *(int32_t *)(v1 + 20)); // 0x2971
    int32_t v5 = *v3 - v4; // 0x2975
    *v3 = v4;
    int32_t result = 0; // eax
    memset((char *)v4, 0, v5 / 4);
    int32_t set_mem = (int32_t)memset((char *)v4, result, v5 % 4);
    if (*(int32_t *)(g4 + 4) == 0) {
        // 0x29cb
        memcpy((char *)v4, (char *)v5, set_mem);
        return result;
    }
    int32_t v6 = *(int32_t *)g4; // 0x2993
    int32_t * v7 = (int32_t *)(v6 + 8); // 0x2995_0
    int32_t v8 = *v7; // 0x2995
    uint32_t v9 = v8 + (*(int32_t *)(g4 + 12) + 3 & -4); // 0x299e
    *v7 = v9;
    int32_t v10; // 0x29b0
    if (v9 > *(int32_t *)(v6 + 4)) {
        // 0x29a8
        *(int32_t *)(v6 + 8) = v8;
        v10 = 0;
        // branch -> 0x29ad
    } else {
        // 0x2990
        v10 = v8;
        // branch -> 0x29ad
    }
    // 0x29ad
    *(int32_t *)*(int32_t *)(g4 + 8) = v10;
    uint32_t v11 = *(int32_t *)(g4 + 12); // 0x29b5
    int32_t v12 = *(int32_t *)*(int32_t *)(g4 + 8); // 0x29b8
    int32_t v13 = *(int32_t *)(g4 + 4); // 0x29ba
    result = v11;
    memcpy((char *)v12, (char *)v13, v11 / 4);
    // branch -> 0x29cb
    // 0x29cb
    memcpy((char *)v12, (char *)v13, result % 4);
    return result;
}

// Address range: 0x2ae2 - 0x2ae5
int32_t _qm_GetTitleId_CXo__QAEKXZ(int32_t a1) {
    // 0x2ae2
    return *(int32_t *)(g4 + 4);
}

// Address range: 0x2b78 - 0x2b7b
int32_t _qm_GetTitleVersion_CXo__QAEKXZ(int32_t a1) {
    // 0x2b78
    return *(int32_t *)(g4 + 8);
}

// Address range: 0x2c13 - 0x2c16
int32_t _qm_GetTitleGameRegion_CXo__QAEKXZ(int32_t a1) {
    // 0x2c13
    return *(int32_t *)(g4 + 12);
}

// Address range: 0x2cb1 - 0x2cb7
int32_t _qm_GetASN1Module_CXo__QAEPAUtagASN1module_t__XZ(int32_t a1) {
    // 0x2cb1
    return g4 + 368;
}

// Address range: 0x2d4d - 0x2d89
int32_t _qm_KerbAllocateEncryptionBuffer__YGJPAVCScratchMemoryAllocator__KKPAKPAPAE_Z(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5) {
    int32_t v1 = a3 + 24; // 0x2d55
    *a4 = v1;
    int32_t * v2 = (int32_t *)(a1 + 8); // 0x2d62_0
    int32_t v3 = *v2; // 0x2d62
    int32_t v4 = v3; // esi
    uint32_t v5 = v3 + (v1 + 3 & -4); // 0x2d68
    *v2 = v5;
    int32_t v6; // 0x2d7d
    if (v5 > *(int32_t *)(a1 + 4)) {
        // 0x2d74
        *(int32_t *)(a1 + 8) = v4;
        v4 = 0;
        v6 = 0;
        // branch -> 0x2d79
    } else {
        // 0x2d4d
        v6 = v4;
        // branch -> 0x2d79
    }
    // 0x2d79
    *a5 = v6;
    int32_t result; // 0x2d87_2
    if (v4 == 0) {
        // 0x2d84
        result = 60;
        // branch -> 0x2d87
    } else {
        // 0x2d79
        result = 0;
        // branch -> 0x2d87
    }
    // 0x2d87
    return result;
}

// Address range: 0x2ece - 0x2f0e
int32_t _qm_KerbAllocateEncryptionBufferWrapper__YGJPAVCScratchMemoryAllocator__KKPAKPAPAE_Z(int32_t a1, int32_t a2, int32_t a3, int32_t * a4) {
    int32_t * v1 = (int32_t *)(a1 + 8); // 0x2ed3_0
    int32_t v2 = *v1; // 0x2ed3
    uint32_t v3 = v2 + (a3 + 27 & -4); // 0x2ee4
    *v1 = v3;
    int32_t v4;
    if (v3 > *(int32_t *)(a1 + 4)) {
        // 0x2ef5
        *(int32_t *)(a1 + 8) = v2;
        *(int32_t *)v4 = 0;
        // branch -> 0x2eff
        // 0x2eff
        // branch -> 0x2f0a
        // 0x2f0a
        return 60;
    }
    // 0x2ef5
    *(int32_t *)v4 = v2;
    if (v2 == 0) {
        // 0x2eff
        // branch -> 0x2f0a
        // 0x2f0a
        return 60;
    }
    // 0x2f04
    *a4 = a3 + 24;
    // branch -> 0x2f0a
    // 0x2f0a
    return 0;
}

// Address range: 0x308d - 0x30c5
int32_t _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(int32_t a1) {
    // 0x308d
    int32_t v1;
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x30b2
    _qm_md5Hmac__YGEPBEK0K0KPAE_Z((char *)v2, *(int32_t *)(v1 + 4));
    return function_30c6();
}

// Address range: 0x30c6 - 0x30d7
int32_t function_30c6(void) {
    // 0x30c6
    return function_30d8();
}

// Address range: 0x30d8 - 0x30e9
int32_t function_30d8(void) {
    // 0x30d8
    return function_30ea();
}

// Address range: 0x30ea - 0x30f5
int32_t function_30ea(void) {
    // 0x30ea
    return function_30f6();
}

// Address range: 0x30f6 - 0x3111
int32_t function_30f6(void) {
    int32_t result = _qm_md5Hmac__YGEPBEK0K0KPAE_Z((char *)(g2 - 20), 16); // 0x3109
    g2 = *(int32_t *)g2;
    return result;
}

// Address range: 0x3255 - 0x32d7
int32_t _qm_KerbAddPrePreAuth__YGJPAVCScratchMemoryAllocator__PADPAUKERB_ENCRYPTION_KEY__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, char * a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = a1; // eax
    uint32_t v3 = *(int32_t *)(a1 + 4); // 0x3263
    int32_t * v4 = (int32_t *)(a1 + 8); // 0x326b_0
    int32_t v5 = *v4; // 0x326b
    uint32_t v6 = v5 + 16; // 0x326e
    *v4 = v6;
    int32_t * v7; // 0x328e_0
    int32_t v8; // 0x32b7_0
    int32_t v9; // 0x3288
    int32_t v10; // 0x32cf
    int32_t v11;
    int32_t v12; // bp-168
    int32_t v13; // bp-172
    int32_t v14;
    uint32_t v15; // 0x3291
    int32_t v16; // 0x328e
    if (v6 > v3) {
        // 0x327d
        *(int32_t *)(v2 + 8) = v5;
        // branch -> 0x3281
        // 0x3281
        v9 = function_3370(v11);
        // branch -> 0x328d
        // 0x328d
        v12 = g3;
        v7 = (int32_t *)(v9 + 8);
        v16 = *v7;
        g3 = v16;
        v15 = v16 + 48;
        *v7 = v15;
        if (v15 > v3) {
            // 0x32a0
            *(int32_t *)(v9 + 8) = g3;
            // branch -> 0x32a4
            // 0x32a4
            g3 = function_336f();
            // branch -> 0x32b0
            // 0x32b0
            v13 = g5;
            v2 = 0;
            v8 = &v14;
            v14 = 0;
            *(int32_t *)(v8 + 4) = 0;
            *(int32_t *)(v8 + 8) = v2;
            *(int32_t *)(v8 + 12) = v2;
            g5 = (int32_t)a2;
            v10 = (int32_t)*a2;
            g1 = v10;
            return function_32d8(v10, v13, v12);
        }
        // 0x32a0
        if (g3 != 0) {
            // 0x32b0
            v13 = g5;
            v2 = 0;
            v8 = &v14;
            v14 = 0;
            *(int32_t *)(v8 + 4) = 0;
            *(int32_t *)(v8 + 8) = v2;
            *(int32_t *)(v8 + 12) = v2;
            g5 = (int32_t)a2;
            v10 = (int32_t)*a2;
            g1 = v10;
            return function_32d8(v10, v13, v12);
        }
        // 0x32a4
        g3 = function_336f();
        // branch -> 0x32b0
        // 0x32b0
        v13 = g5;
        v2 = 0;
        v8 = &v14;
        v14 = 0;
        *(int32_t *)(v8 + 4) = 0;
        *(int32_t *)(v8 + 8) = v2;
        *(int32_t *)(v8 + 12) = v2;
        g5 = (int32_t)a2;
        v10 = (int32_t)*a2;
        g1 = v10;
        return function_32d8(v10, v13, v12);
    }
    // 0x327d
    if (v5 != 0) {
        // 0x327d
        // branch -> 0x328d
        // 0x328d
        v12 = g3;
        v7 = (int32_t *)(v2 + 8);
        v16 = *v7;
        g3 = v16;
        v15 = v16 + 48;
        *v7 = v15;
        if (v15 > v3) {
            // 0x32a0
            *(int32_t *)(v2 + 8) = g3;
            // branch -> 0x32a4
        } else {
            // 0x32a0
            if (g3 != 0) {
                // 0x32b0
                v13 = g5;
                v2 = 0;
                v8 = &v14;
                v14 = 0;
                *(int32_t *)(v8 + 4) = 0;
                *(int32_t *)(v8 + 8) = v2;
                *(int32_t *)(v8 + 12) = v2;
                g5 = (int32_t)a2;
                v10 = (int32_t)*a2;
                g1 = v10;
                return function_32d8(v10, v13, v12);
            }
        }
        // 0x32a4
        g3 = function_336f();
        // branch -> 0x32b0
        // 0x32b0
        v13 = g5;
        v2 = 0;
        v8 = &v14;
        v14 = 0;
        *(int32_t *)(v8 + 4) = 0;
        *(int32_t *)(v8 + 8) = v2;
        *(int32_t *)(v8 + 12) = v2;
        g5 = (int32_t)a2;
        v10 = (int32_t)*a2;
        g1 = v10;
        return function_32d8(v10, v13, v12);
    }
    // 0x3281
    v9 = function_3370(v11);
    // branch -> 0x328d
    // 0x328d
    v12 = g3;
    v7 = (int32_t *)(v9 + 8);
    v16 = *v7;
    g3 = v16;
    v15 = v16 + 48;
    *v7 = v15;
    if (v15 > v3) {
        // 0x32a0
        *(int32_t *)(v9 + 8) = g3;
        // branch -> 0x32a4
    } else {
        // 0x32a0
        if (g3 != 0) {
            // 0x32b0
            v13 = g5;
            v2 = 0;
            v8 = &v14;
            v14 = 0;
            *(int32_t *)(v8 + 4) = 0;
            *(int32_t *)(v8 + 8) = v2;
            *(int32_t *)(v8 + 12) = v2;
            g5 = (int32_t)a2;
            v10 = (int32_t)*a2;
            g1 = v10;
            return function_32d8(v10, v13, v12);
        }
    }
    // 0x32a4
    g3 = function_336f();
    // branch -> 0x32b0
    // 0x32b0
    v13 = g5;
    v2 = 0;
    v8 = &v14;
    v14 = 0;
    *(int32_t *)(v8 + 4) = 0;
    *(int32_t *)(v8 + 8) = v2;
    *(int32_t *)(v8 + 12) = v2;
    g5 = (int32_t)a2;
    v10 = (int32_t)*a2;
    g1 = v10;
    return function_32d8(v10, v13, v12);
}

// Address range: 0x32d8 - 0x3304
int32_t function_32d8(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(g2 + 112); // 0x32d8_0
    *v1 = *v1 + 1;
    *(char *)(g5 + *(int32_t *)(g2 + 116)) = (char)g1;
    return function_3305(*(int32_t *)(*(int32_t *)(g2 + 120) + 8));
}

// Address range: 0x3305 - 0x331c
int32_t function_3305(int32_t a1) {
    // 0x3305
    return function_331d();
}

// Address range: 0x331d - 0x332b
int32_t function_331d(void) {
    // 0x331d
    int32_t v1;
    _qm_KerbGetCurrentTime__YGXPAT_LARGE_INTEGER___Z(v1, 0);
    return function_332c();
}

// Address range: 0x332c - 0x333a
int32_t function_332c(void) {
    // 0x332c
    return function_333b();
}

// Address range: 0x333b - 0x3346
int32_t function_333b(void) {
    // 0x333b
    return function_3347();
}

// Address range: 0x3347 - 0x3353
int32_t function_3347(void) {
    // 0x3347
    return function_3354();
}

// Address range: 0x3354 - 0x336e
int32_t function_3354(void) {
    int32_t result = *(int32_t *)(g2 + 124); // 0x3354
    *(int32_t *)(g7 + 4) = 204;
    *(int32_t *)(g7 + 8) = 48;
    *(int32_t *)(g7 + 12) = g3;
    int32_t * v1 = (int32_t *)result; // 0x3368_0
    *(int32_t *)g7 = *v1;
    *v1 = g7;
    int32_t v2;
    g5 = v2;
    return result;
}

// Address range: 0x336f - 0x336f
int32_t function_336f(void) {
    // 0x336f
    int32_t result;
    return result;
}

// Address range: 0x3370 - 0x337a
int32_t function_3370(int32_t a1) {
    int32_t result = *(int32_t *)(g2 + 100); // 0x3370
    g2 += 104;
    return result;
}

// Address range: 0x3527 - 0x35b5
int32_t _qm_KerbAddEchoPreAuth__YGJPAVCScratchMemoryAllocator__KPAEPAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t a2, char * a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t * v1 = (int32_t *)(a1 + 8); // 0x352e_0
    int32_t v2 = *v1; // 0x352e
    uint32_t v3 = *(int32_t *)(a1 + 4); // 0x3536
    uint32_t v4 = v2 + 16; // 0x3539
    *v1 = v4;
    int32_t v5;
    if (v4 > v3) {
        // 0x3548
        *(int32_t *)(a1 + 8) = v2;
        // branch -> 0x354c
        // 0x354c
        // branch -> 0x35ae
        // 0x35ae
        g2 = v5;
        return -0x3fffff66;
    }
    // 0x3548
    if (v2 == 0) {
        // 0x354c
        // branch -> 0x35ae
        // 0x35ae
        g2 = v5;
        return -0x3fffff66;
    }
    int32_t * v6 = (int32_t *)(a1 + 8); // 0x3556_0
    int32_t v7 = *v6; // 0x3556
    uint32_t v8 = v7 + (a2 + 3 & -4); // 0x3563
    *v6 = v8;
    if (v8 > v3) {
        // 0x3571
        *(int32_t *)(a1 + 8) = v7;
        // branch -> 0x3575
    } else {
        // 0x3571
        if (v7 != 0) {
            char * v9 = (char *)v7;
            memcpy(v9, a3, a2 / 4);
            memcpy(v9, a3, a2 % 4);
            *(int32_t *)(v2 + 8) = a2;
            int32_t v10 = (int32_t)a4; // eax
            *(int32_t *)(v2 + 4) = 205;
            *(int32_t *)(v2 + 12) = v7;
            *(int32_t *)v2 = *(int32_t *)v10;
            *(int32_t *)v10 = v2;
            // branch -> 0x35ac
            // 0x35ac
            // branch -> 0x35ae
            // 0x35ae
            g2 = v5;
            return 0;
        }
    }
    // 0x3575
    // branch -> 0x35ac
    // 0x35ac
    // branch -> 0x35ae
    // 0x35ae
    g2 = v5;
    return -0x3fffff66;
}

// Address range: 0x3710 - 0x37a9
int32_t _qm_KerbAddClientVersionPreAuth__YGJPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x371a
    g7 = a1;
    int32_t * v3 = (int32_t *)(a1 + 8); // 0x371f_0
    int32_t v4 = *v3; // 0x371f
    g3 = v4;
    uint32_t v5 = *(int32_t *)(a1 + 4); // 0x3722
    uint32_t v6 = v4 + 16; // 0x3725
    *v3 = v6;
    int32_t * v7; // 0x3745_0
    int32_t * v8; // 0x3774_0
    int32_t result; // 0x37a5
    int32_t v9; // edi
    int32_t v10;
    int32_t v11; // 0x3781
    uint32_t v12; // 0x3748
    int32_t v13; // 0x376a
    int32_t v14; // 0x3745
    int32_t v15; // 0x376d
    int32_t v16; // 0x3787
    int32_t v17; // 0x378a
    int32_t v18; // 0x378d
    if (v6 > v5) {
        // 0x3734
        *(int32_t *)(g7 + 8) = g3;
        // branch -> 0x3738
        // 0x3738
        function_3832(v2, v10);
        // branch -> 0x3744
        // 0x3744
        v7 = (int32_t *)(g7 + 8);
        v14 = *v7;
        v9 = v14;
        v12 = v14 + 148;
        *v7 = v12;
        if (v12 > v5) {
            // 0x375a
            *(int32_t *)(g7 + 8) = v9;
            // branch -> 0x375e
            // 0x375e
            function_3831();
            // branch -> 0x376a
            // 0x376a
            v13 = g7;
            v15 = *(int32_t *)(v13 + 8);
            *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20)) = v15;
            v8 = (int32_t *)(g7 + 20);
            *v8 = *v8 + 1;
            v11 = g7;
            _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(v11);
            v16 = *(int32_t *)(g7 + 56);
            v17 = *(int32_t *)(v16 + 8);
            v18 = *(int32_t *)(v16 + 4);
            g1 = v18;
            result = function_37aa(g5 + 20, 128, (int32_t)"Xbox Version=%s Title=0x%08X TitleVersion=%d", (int32_t)"1.00.5933.1", v18, v17, v11);
            return result;
        }
        // 0x375a
        if (v9 != 0) {
            // 0x376a
            v13 = g7;
            v15 = *(int32_t *)(v13 + 8);
            *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20)) = v15;
            v8 = (int32_t *)(g7 + 20);
            *v8 = *v8 + 1;
            v11 = g7;
            _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(v11);
            v16 = *(int32_t *)(g7 + 56);
            v17 = *(int32_t *)(v16 + 8);
            v18 = *(int32_t *)(v16 + 4);
            g1 = v18;
            result = function_37aa(g5 + 20, 128, (int32_t)"Xbox Version=%s Title=0x%08X TitleVersion=%d", (int32_t)"1.00.5933.1", v18, v17, v11);
            return result;
        }
        // 0x375e
        function_3831();
        // branch -> 0x376a
        // 0x376a
        v13 = g7;
        v15 = *(int32_t *)(v13 + 8);
        *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20)) = v15;
        v8 = (int32_t *)(g7 + 20);
        *v8 = *v8 + 1;
        v11 = g7;
        _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(v11);
        v16 = *(int32_t *)(g7 + 56);
        v17 = *(int32_t *)(v16 + 8);
        v18 = *(int32_t *)(v16 + 4);
        g1 = v18;
        result = function_37aa(g5 + 20, 128, (int32_t)"Xbox Version=%s Title=0x%08X TitleVersion=%d", (int32_t)"1.00.5933.1", v18, v17, v11);
        return result;
    }
    // 0x3734
    if (g3 != 0) {
        // 0x3744
        v7 = (int32_t *)(g7 + 8);
        v14 = *v7;
        v9 = v14;
        v12 = v14 + 148;
        *v7 = v12;
        if (v12 > v5) {
            // 0x375a
            *(int32_t *)(g7 + 8) = v9;
            // branch -> 0x375e
        } else {
            // 0x375a
            if (v9 != 0) {
                // 0x376a
                v13 = g7;
                v15 = *(int32_t *)(v13 + 8);
                *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20)) = v15;
                v8 = (int32_t *)(g7 + 20);
                *v8 = *v8 + 1;
                v11 = g7;
                _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(v11);
                v16 = *(int32_t *)(g7 + 56);
                v17 = *(int32_t *)(v16 + 8);
                v18 = *(int32_t *)(v16 + 4);
                g1 = v18;
                result = function_37aa(g5 + 20, 128, (int32_t)"Xbox Version=%s Title=0x%08X TitleVersion=%d", (int32_t)"1.00.5933.1", v18, v17, v11);
                return result;
            }
        }
        // 0x375e
        function_3831();
        // branch -> 0x376a
        // 0x376a
        v13 = g7;
        v15 = *(int32_t *)(v13 + 8);
        *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20)) = v15;
        v8 = (int32_t *)(g7 + 20);
        *v8 = *v8 + 1;
        v11 = g7;
        _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(v11);
        v16 = *(int32_t *)(g7 + 56);
        v17 = *(int32_t *)(v16 + 8);
        v18 = *(int32_t *)(v16 + 4);
        g1 = v18;
        result = function_37aa(g5 + 20, 128, (int32_t)"Xbox Version=%s Title=0x%08X TitleVersion=%d", (int32_t)"1.00.5933.1", v18, v17, v11);
        return result;
    }
    // 0x3738
    function_3832(v2, v10);
    // branch -> 0x3744
    // 0x3744
    v7 = (int32_t *)(g7 + 8);
    v14 = *v7;
    v9 = v14;
    v12 = v14 + 148;
    *v7 = v12;
    if (v12 > v5) {
        // 0x375a
        *(int32_t *)(g7 + 8) = v9;
        // branch -> 0x375e
    } else {
        // 0x375a
        if (v9 != 0) {
            // 0x376a
            v13 = g7;
            v15 = *(int32_t *)(v13 + 8);
            *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20)) = v15;
            v8 = (int32_t *)(g7 + 20);
            *v8 = *v8 + 1;
            v11 = g7;
            _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(v11);
            v16 = *(int32_t *)(g7 + 56);
            v17 = *(int32_t *)(v16 + 8);
            v18 = *(int32_t *)(v16 + 4);
            g1 = v18;
            result = function_37aa(g5 + 20, 128, (int32_t)"Xbox Version=%s Title=0x%08X TitleVersion=%d", (int32_t)"1.00.5933.1", v18, v17, v11);
            return result;
        }
    }
    // 0x375e
    function_3831();
    // branch -> 0x376a
    // 0x376a
    v13 = g7;
    v15 = *(int32_t *)(v13 + 8);
    *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20)) = v15;
    v8 = (int32_t *)(g7 + 20);
    *v8 = *v8 + 1;
    v11 = g7;
    _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(v11);
    v16 = *(int32_t *)(g7 + 56);
    v17 = *(int32_t *)(v16 + 8);
    v18 = *(int32_t *)(v16 + 4);
    g1 = v18;
    result = function_37aa(g5 + 20, 128, (int32_t)"Xbox Version=%s Title=0x%08X TitleVersion=%d", (int32_t)"1.00.5933.1", v18, v17, v11);
    return result;
}

// Address range: 0x37aa - 0x37f2
int32_t function_37aa(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = g1 + 1; // 0x37ad
    *(int32_t *)(g2 + 8) = v1;
    if (v1 >= 0) {
        // 0x37de
        return function_37f3(g2 - 20);
    }
    int32_t * v2 = (int32_t *)(g7 + 20); // 0x37b3_0
    *v2 = *v2 - 1;
    int32_t v3 = *(int32_t *)(g7 + 24 + 4 * *(int32_t *)(g7 + 20)); // 0x37b9
    char * v4 = (char *)v3;
    int32_t * v5 = (int32_t *)(g7 + 8); // 0x37bd_0
    uint32_t v6 = *v5 - v3; // 0x37c0
    *v5 = v3;
    memset(v4, 0, v6 / 4);
    *(int32_t *)(g2 - 4) = -0x3fffff66;
    memset(v4, 0, v6 % 4);
    g5 = function_3831();
    return 0;
}

// Address range: 0x37f3 - 0x3830
int32_t function_37f3(int32_t a1) {
    // 0x37f3
    *(int32_t *)(g3 + 12) = g5;
    *(int32_t *)(g3 + 8) = *(int32_t *)(g2 + 8) + 20;
    int32_t * v1 = (int32_t *)(g7 + 20); // 0x37ff_0
    *v1 = *v1 - 1;
    int32_t v2 = *(int32_t *)(g7 + 24 + 4 * *(int32_t *)(g7 + 20)); // 0x3805
    char * v3 = (char *)v2;
    g5 = v2;
    int32_t * v4 = (int32_t *)(g7 + 8); // 0x3809_0
    int32_t v5 = *v4 - v2; // 0x380c
    *v4 = v2;
    memset(v3, 0, v5 / 4);
    memset(v3, 0, v5 % 4);
    int32_t result = *(int32_t *)(g2 + 20); // 0x3821
    *(int32_t *)(g3 + 4) = 206;
    int32_t * v6 = (int32_t *)result; // 0x382b_0
    *(int32_t *)g3 = *v6;
    *v6 = g3;
    return result;
}

// Address range: 0x3831 - 0x3831
int32_t function_3831(void) {
    // 0x3831
    int32_t result;
    return result;
}

// Address range: 0x3832 - 0x383a
int32_t function_3832(int32_t a1, int32_t a2) {
    // 0x3832
    g7 = a1;
    g3 = a2;
    return *(int32_t *)(g2 - 4);
}

// Address range: 0x3a27 - 0x3a5f
int32_t _qm_KerbComputeCompoundIdentityKey__YGXPBUKERB_ENCRYPTION_KEY__PBUXKERB_TGT_CONTEXT__PAE_Z(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 8); // 0x3a4c
    _qm_md5Hmac__YGEPBEK0K0KPAE_Z((char *)v1, *(int32_t *)(a1 + 4));
    return function_3a60();
}

// Address range: 0x3a60 - 0x3a71
int32_t function_3a60(void) {
    // 0x3a60
    return function_3a72();
}

// Address range: 0x3a72 - 0x3a88
int32_t function_3a72(void) {
    // 0x3a72
    return function_3a89();
}

// Address range: 0x3a89 - 0x3a94
int32_t function_3a89(void) {
    // 0x3a89
    return function_3a95();
}

// Address range: 0x3a95 - 0x3ab0
int32_t function_3a95(void) {
    int32_t result = _qm_md5Hmac__YGEPBEK0K0KPAE_Z((char *)(g2 - 20), 16); // 0x3aa8
    g2 = *(int32_t *)g2;
    return result;
}

// Address range: 0x3bcb - 0x3bf1
int32_t _qm_KerbInitAsn__YGJPAVCScratchMemoryAllocator__PAPAUASN1encoding_s__PAPAUASN1decoding_s___Z(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3bcb
    g4 = a1;
    g7 = 0;
    g5 = 60;
    int32_t v1 = *(int32_t *)(a1 + 56) + 368; // 0x3bda
    g1 = v1;
    return function_3bf2(a1, v1);
}

// Address range: 0x3bf2 - 0x3bfe
int32_t function_3bf2(int32_t a1, int32_t a2) {
    // 0x3bf2
    return function_3bff(0, a1, a2);
}

// Address range: 0x3bff - 0x3c0b
int32_t function_3bff(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3bff
    int32_t result; // 0x3c05
    if (g1 == g7) {
        // 0x3c03
        result = 0;
        // branch -> 0x3c05
    } else {
        // 0x3bff
        result = g5;
        // branch -> 0x3c05
    }
    // 0x3c05
    int32_t v1;
    g5 = v1;
    return result;
}

// Address range: 0x3d24 - 0x3d81
int32_t _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t v1;
    g2 = &v1;
    g3 = a1;
    int32_t v2 = 0; // bp-8
    _qm_KerbInitAsn__YGJPAVCScratchMemoryAllocator__PAPAUASN1encoding_s__PAPAUASN1decoding_s___Z(a1, (int32_t)&v2, 0);
    int32_t v3 = g3; // 0x3d4b
    int32_t v4 = *(int32_t *)(v3 + 8); // 0x3d4e
    g7 = (int32_t)a5;
    *(int32_t *)(v3 + 24 + 4 * *(int32_t *)(v3 + 20)) = v4;
    int32_t * v5 = (int32_t *)(g3 + 20); // 0x3d58_0
    *v5 = *v5 + 1;
    int32_t v6 = *a5; // 0x3d5b
    g1 = v6;
    int32_t v7 = g5; // 0x3d60
    g5 = (int32_t)a4;
    return function_3d82(v2, a2, a3, v6 == v7 ? 16 : 8);
}

// Address range: 0x3d82 - 0x3e01
int32_t function_3d82(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x3d82
    if (g1 < 0) {
        // 0x3d88
        *(int32_t *)(g2 + 8) = 60;
        // branch -> 0x3db7
    } else {
        int32_t v1 = *(int32_t *)g7; // 0x3d91
        int32_t v2 = g2; // 0x3d95
        int32_t v3 = *(int32_t *)(v2 - 4); // 0x3d95
        g1 = v3;
        if (v1 == 0) {
            // 0x3dde
            *(int32_t *)g5 = *(int32_t *)(v3 + 24);
            int32_t v4 = *(int32_t *)(g1 + 16); // 0x3de3
            *(int32_t *)g7 = v4;
            g5 = *(int32_t *)g5;
            *(int32_t *)(g2 + 16) = v4;
            *(int32_t *)(g2 + 12) = g5;
            return function_3e02(0);
        }
        // 0x3d9a
        if (v1 == *(int32_t *)(v3 + 16)) {
            // 0x3d9f
            g7 = *(int32_t *)(v2 - 8);
            *(int32_t *)g5 = *(int32_t *)(v3 + 24);
            return function_3e31(0, a1);
        }
        // 0x3dac
        *(int32_t *)g5 = 0;
        *(int32_t *)g7 = 0;
        *(int32_t *)(g2 + 8) = -0x3fffff66;
        // branch -> 0x3db7
    }
    int32_t v5 = g3; // 0x3db7
    int32_t * v6 = (int32_t *)(v5 + 20); // 0x3dba_0
    *v6 = *v6 - 1;
    int32_t v7 = g3; // 0x3dbd
    int32_t v8 = *(int32_t *)(v7 + 24 + 4 * *(int32_t *)(v7 + 20)); // 0x3dc0
    char * v9 = (char *)v8;
    uint32_t v10 = *(int32_t *)(v5 + 8) - v8; // 0x3dc4
    *(int32_t *)(v7 + 8) = v8;
    memset(v9, 0, v10 / 4);
    memset(v9, 0, v10 % 4);
    return function_3e91();
}

// Address range: 0x3e02 - 0x3e30
int32_t function_3e02(int32_t a1) {
    int32_t v1;
    int32_t v2 = &v1; // 0x3e05_0
    uint32_t v3 = g5; // 0x3e0e
    char * v4 = (char *)*(int32_t *)(g2 + 16);
    g5 = v2;
    memcpy((char *)&v1, v4, v3 / 4);
    memcpy((char *)&v1, v4, v3 % 4);
    g7 = *(int32_t *)(g2 + 12);
    *(int32_t *)(g2 - 12) = *(int32_t *)(g2 + 24);
    *(int32_t *)(g2 - 16) = v2;
    return *(int32_t *)(g2 - 4);
}

// Address range: 0x3e31 - 0x3e90
int32_t function_3e31(int32_t a1, int32_t a2) {
    // 0x3e31
    _qm_KerbTermAsn__YGXPAUASN1encoding_s__PAUASN1decoding_s___Z(g1);
    int32_t * v1 = (int32_t *)(g3 + 20); // 0x3e39_0
    *v1 = *v1 - 1;
    int32_t v2 = *(int32_t *)(g3 + 24 + 4 * *(int32_t *)(g3 + 20)); // 0x3e3f
    char * v3 = (char *)v2;
    int32_t * v4 = (int32_t *)(g3 + 8); // 0x3e43_0
    uint32_t v5 = *v4 - v2; // 0x3e46
    *v4 = v2;
    memset(v3, 0, v5 / 4);
    memset(v3, 0, v5 % 4);
    int32_t * v6 = (int32_t *)(g3 + 8); // 0x3e61_0
    int32_t v7 = *v6; // 0x3e61
    g5 = v7;
    uint32_t v8 = (g7 + 3 & -4) + v7; // 0x3e6a
    *v6 = v8;
    int32_t v9; // 0x3e81
    if (v8 > *(int32_t *)(g3 + 4)) {
        // 0x3e74
        *(int32_t *)(g3 + 8) = g5;
        g5 = 0;
        v9 = 0;
        // branch -> 0x3e79
    } else {
        // 0x3e31
        v9 = g5;
        // branch -> 0x3e79
    }
    int32_t result = g7; // ecx
    int32_t v10 = *(int32_t *)(g2 - 16); // 0x3e7e
    g7 = v10;
    *(int32_t *)*(int32_t *)(g2 - 12) = v9;
    memcpy((char *)g5, (char *)v10, result / 4);
    return result;
}

// Address range: 0x3e91 - 0x3e9d
int32_t function_3e91(void) {
    int32_t result = *(int32_t *)(g2 + 8); // 0x3e91
    g5 = *(int32_t *)(g2 - 32);
    g7 = *(int32_t *)(g2 - 28);
    g3 = *(int32_t *)(g2 - 24);
    g2 = *(int32_t *)g2;
    return result;
}

// Address range: 0x3ff3 - 0x402a
int32_t _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5, int32_t a6) {
    int32_t v1;
    g2 = &v1;
    int32_t v2; // bp-8
    int32_t v3 = &v2; // 0x3ff6_0
    v2 = 0;
    g1 = _qm_KerbInitAsn__YGJPAVCScratchMemoryAllocator__PAPAUASN1encoding_s__PAPAUASN1decoding_s___Z(a1, 0, v3);
    g3 = v3;
    g7 = (int32_t)a5;
    *a5 = g5;
    return function_402b(v2, g7);
}

// Address range: 0x402b - 0x405a
int32_t function_402b(int32_t a1, int32_t a2) {
    int32_t v1 = g5; // 0x404c
    int32_t v2;
    int32_t result; // 0x4054
    if (g1 < g5) {
        // 0x402f
        if (g1 != -1009) {
            // 0x4036
            if (g1 != -1002) {
                // 0x403d
                // branch -> 0x4047
                // 0x4047
                g3 = 60;
                *(int32_t *)g7 = g5;
                v1 = g5;
                // branch -> 0x4049
                // 0x4049
                _qm_KerbTermAsn__YGXPAUASN1encoding_s__PAUASN1decoding_s___Z(v1);
                g7 = v1;
                g5 = *(int32_t *)(g2 - 4);
                result = g3;
                g3 = v2;
                g2 = *(int32_t *)g2;
                return result;
            }
        }
        // 0x4042
        // branch -> 0x4047
        // 0x4047
        g3 = -0x7fffffff;
        *(int32_t *)g7 = g5;
        v1 = g5;
        // branch -> 0x4049
    }
    // 0x4049
    _qm_KerbTermAsn__YGXPAUASN1encoding_s__PAUASN1decoding_s___Z(v1);
    g7 = v1;
    g5 = *(int32_t *)(g2 - 4);
    result = g3;
    g3 = v2;
    g2 = *(int32_t *)g2;
    return result;
}

// Address range: 0x41d8 - 0x420d
int32_t _qm_KerbDecryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__PAUKERB_ENCRYPTION_KEY__KPAKPAE_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x41d8
    g7 = 0;
    int32_t v1 = *(int32_t *)(a2 + 12); // 0x41e7
    int32_t v2 = *(int32_t *)(a2 + 16); // 0x41ea
    int32_t v3 = *(int32_t *)(a3 + 4); // 0x41f3
    int32_t v4 = *(int32_t *)(a3 + 8); // 0x41f6
    int32_t v5;
    int32_t result; // 0x4207
    if (_qm_rc4HmacDecrypt__YGJPBEKKPAEK1PAK_Z(v4, v3, a4, (char *)v2, v1, v5, (int32_t *)a5) > -1) {
        // 0x41d8
        result = g7;
        // branch -> 0x4207
    } else {
        // 0x4202
        result = -0x3fffff93;
        // branch -> 0x4207
    }
    // 0x4207
    g7 = v4;
    g2 = v3;
    return result;
}

// Address range: 0x4353 - 0x43be
int32_t _qm_KerbConstructPrincipalName__YGJPAVCScratchMemoryAllocator__PAUKERB_PRINCIPAL_NAME__KPAD2_Z(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = g5; // 0x435a
    *a2 = a3;
    int32_t * v2 = (int32_t *)(a1 + 8); // 0x4363_0
    int32_t v3 = *v2; // 0x4363
    int32_t v4 = v3; // edx
    uint32_t v5 = v3 + 8; // 0x4366
    int32_t result = 0; // eax
    *v2 = v5;
    int32_t v6; // 0x438a
    if (v5 > *(int32_t *)(a1 + 4)) {
        // 0x4373
        *(int32_t *)(a1 + 8) = v4;
        v4 = 0;
        v6 = 0;
        // branch -> 0x4378
    } else {
        // 0x4353
        v6 = v4;
        // branch -> 0x4378
    }
    int32_t v7 = result; // 0x4378
    int32_t result2; // 0x43bc_2
    int32_t v8;
    if (v6 == v7) {
        // 0x437c
        result2 = 60;
        // branch -> 0x43b9
    } else {
        int32_t v9 = g3; // bp-16
        *(int32_t *)(v6 + 4) = a4;
        *(int32_t *)v4 = result;
        *(int32_t *)((int32_t)a2 + 4) = v4;
        if (v7 != a5) {
            int32_t * v10 = (int32_t *)(a1 + 8); // 0x4394_0
            int32_t v11 = *v10; // 0x4394
            uint32_t v12 = v11 + 8; // 0x4397
            *v10 = v12;
            if (v12 > *(int32_t *)(a1 + 4)) {
                // 0x43a7
                *(int32_t *)(a1 + 8) = v11;
                // branch -> 0x43ab
            } else {
                // 0x43a7
                if (v11 != 0) {
                    // 0x43b0
                    *(int32_t *)v11 = 0;
                    *(int32_t *)(v11 + 4) = a5;
                    *(int32_t *)v4 = v11;
                    // branch -> 0x43b8
                    // 0x43b8
                    g3 = v9;
                    // branch -> 0x43b9
                    // 0x43b9
                    g5 = v1;
                    g2 = v8;
                    return result;
                }
            }
            // 0x43ab
            result = 60;
            // branch -> 0x43b8
        }
        // 0x43b8
        g3 = v9;
        result2 = result;
        // branch -> 0x43b9
    }
    // 0x43b9
    g5 = v1;
    g2 = v8;
    return result2;
}

// Address range: 0x4519 - 0x4535
int32_t _qm_KerbMultiStringToPrincipalName__YGJPAVCScratchMemoryAllocator__PADPAUKERB_PRINCIPAL_NAME___Z(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5) {
    int32_t v1 = (int32_t)a3;
    int32_t v2;
    g2 = &v2;
    int32_t v3 = g3; // 0x4521
    g3 = v1;
    int32_t v4 = g7; // 0x4525
    g7 = a2;
    g1 = 0;
    *a3 = 0;
    *(int32_t *)(v1 + 4) = g1;
    return function_4536(a2, g5, v4, v3, 0, v2);
}

// Address range: 0x4536 - 0x45a9
int32_t function_4536(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x4536
    *(int32_t *)g3 = g1;
    int32_t v1 = g7; // 0x4540
    int32_t v2 = (int32_t)*(char *)v1 | g6 & -256; // 0x453e
    int32_t v3 = v1 + 1; // 0x4540
    // branch -> 0x453e
    while (v2 != 0) {
        // 0x453e
        v1 = v3;
        v2 = (int32_t)*(char *)v1 | v2 & -256;
        v3 = v1 + 1;
        // continue -> 0x453e
    }
    int32_t v4 = v3; // eax
    int32_t v5 = 0; // ebx
    if (*(char *)v3 == 0) {
        // 0x45a0
        g7 = a2;
        g3 = a3;
        return *(int32_t *)(g2 - 4);
    }
    int32_t v6 = *(int32_t *)(g2 + 8); // 0x4551
    int32_t * v7 = (int32_t *)(v6 + 8); // bp+019
    int32_t v8 = *v7; // 0x455420
    int32_t v9 = v8; // ecx
    int32_t v10 = v8 + 8; // 0x455721
    int32_t v11 = v10; // edx
    *v7 = v10;
    if (v10 > *(int32_t *)(v6 + 4)) {
        // 0x4567
        *(int32_t *)(v6 + 8) = v9;
        // branch -> 0x4599
    } else {
        while (true) {
            int32_t v12 = v9;
            if (v12 != 0) {
                // 0x456b
                *(int32_t *)v12 = 0;
                *(int32_t *)(v9 + 4) = v4;
                if (v5 == 0) {
                    int32_t v13 = *(int32_t *)(g2 + 16); // 0x4579
                    v11 = v13;
                    *(int32_t *)(v13 + 4) = v9;
                    // branch -> 0x457f
                } else {
                    // 0x4575
                    *(int32_t *)v5 = v9;
                    // branch -> 0x457f
                }
                // 0x457f
                v5 = v9;
                int32_t v14 = v4; // 0x4588
                int32_t v15 = (int32_t)*(char *)v14 | v11 & -256; // 0x4586
                int32_t v16 = v14 + 1; // 0x4588
                // branch -> 0x4586
                while (v15 != 0) {
                    // 0x4586
                    v14 = v16;
                    v15 = (int32_t)*(char *)v14 | v15 & -256;
                    v16 = v14 + 1;
                    // continue -> 0x4586
                }
                // 0x458d
                v4 = v16;
                if (*(char *)v16 == 0) {
                    // 0x45a0
                    g7 = a2;
                    g3 = a3;
                    return *(int32_t *)(g2 - 4);
                }
                int32_t * v17 = (int32_t *)(v6 + 8); // 0x4554_0
                int32_t v18 = *v17; // 0x4554
                v9 = v18;
                int32_t v19 = v18 + 8; // 0x4557
                v11 = v19;
                *v17 = v19;
                if (v19 > *(int32_t *)(v6 + 4)) {
                    // break -> 0x4567
                    break;
                }
                // continue -> 0x4567
                continue;
            }
            // 0x4599
            *(int32_t *)(g2 - 4) = 60;
            // branch -> 0x45a0
            // 0x45a0
            g7 = a2;
            g3 = a3;
            return *(int32_t *)(g2 - 4);
        }
        // 0x4567
        *(int32_t *)(v6 + 8) = v9;
        // branch -> 0x4599
    }
    // 0x4599
    *(int32_t *)(g2 - 4) = 60;
    // branch -> 0x45a0
    // 0x45a0
    g7 = a2;
    g3 = a3;
    return *(int32_t *)(g2 - 4);
}

// Address range: 0x4719 - 0x4750
int32_t _qm_rc4HmacEncrypt__YGJPAVCScratchMemoryAllocator__PBEKKPAEK2PAK_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x4719
    _qm_md5Hmac__YGEPBEK0K0KPAE_Z((char *)a2, a3);
    g5 = a6;
    int32_t v1;
    g7 = v1;
    function_4751(v1 + 24, a5, a6, a2);
    return 0;
}

// Address range: 0x4751 - 0x476e
int32_t function_4751(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = *(int32_t *)(g2 + 36); // 0x4751
    g3 = v1;
    *(int32_t *)v1 = g5 + 24;
    int32_t v2 = 0; // eax
    int32_t v3 = g7; // 0x475b
    *(int32_t *)v3 = 0;
    *(int32_t *)(v3 + 4) = v2;
    *(int32_t *)(v3 + 8) = v2;
    *(int32_t *)(v3 + 12) = v2;
    function_476f(g7 + 16, 8);
    return 0;
}

// Address range: 0x476f - 0x47ad
int32_t function_476f(int32_t a1, int32_t a2) {
    // 0x476f
    _qm_md5Hmac__YGEPBEK0K0KPAE_Z((char *)(g2 - 16), 16);
    _qm_md5Hmac__YGEPBEK0K0KPAE_Z((char *)(g2 - 16), 16);
    function_47ae();
    return 0;
}

// Address range: 0x47ae - 0x47c0
int32_t function_47ae(void) {
    // 0x47ae
    function_47c1(g2 - 292, *(int32_t *)g3 - 16);
    return 0;
}

// Address range: 0x47c1 - 0x47c9
int32_t function_47c1(int32_t a1, int32_t a2) {
    // 0x47c1
    int32_t v1;
    g5 = v1;
    g7 = a1;
    g3 = a2;
    return 0;
}

// Address range: 0x49a4 - 0x4a2d
int32_t _qm_KerbComputeRequestBodyChecksum__YGJPAVCScratchMemoryAllocator__PAUKERB_KDC_REQUEST_BODY__PAUKERB_CHECKSUM___Z(int32_t a1, int32_t a2, int32_t * a3, int32_t a4) {
    int32_t v1 = (int32_t)a3;
    int32_t v2;
    g2 = &v2;
    int32_t v3 = g3; // 0x49ad
    g3 = a1;
    int32_t v4 = g7; // 0x49b1
    int32_t v5 = 0; // eax
    *a3 = 0;
    *(int32_t *)(v1 + 4) = v5;
    *(int32_t *)(v1 + 8) = v5;
    int32_t v6 = g3; // 0x49ba
    int32_t * v7 = (int32_t *)(v6 + 8); // 0x49ba_0
    int32_t v8 = *v7; // 0x49ba
    v5 = v8;
    uint32_t v9 = v8 + 16; // 0x49bf
    int32_t v10 = 0;
    int32_t v11 = 0;
    *v7 = v9;
    int32_t v12; // 0x49da
    if (v9 > *(int32_t *)(v6 + 4)) {
        // 0x49d3
        *(int32_t *)(g3 + 8) = v5;
        v12 = 0;
        // branch -> 0x49d8
    } else {
        // 0x49a4
        v12 = v5;
        // branch -> 0x49d8
    }
    // 0x49d8
    *(int32_t *)(v1 + 8) = v12;
    if (v12 == 0) {
        // 0x49df
        function_4a75(v4, v3);
        // branch -> 0x49eb
    }
    // 0x49eb
    *(int32_t *)(v1 + 4) = 16;
    *(int32_t *)v1 = 7;
    int32_t v13 = g3; // 0x49f8
    int32_t v14 = *(int32_t *)(v13 + 8); // 0x49fb
    *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20)) = v14;
    int32_t * v15 = (int32_t *)(g3 + 20); // 0x4a02_0
    *v15 = *v15 + 1;
    int32_t v16 = g3; // 0x4a12
    int32_t v17 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(v16, a2, 42, &v10, &v11, g5, v4, v3); // 0x4a13
    if (v17 != 0) {
        // 0x4a1c
        function_4a53(v16);
        // branch -> 0x4a25
    }
    // 0x4a25
    return function_4a2e();
}

// Address range: 0x4a2e - 0x4a3c
int32_t function_4a2e(void) {
    // 0x4a2e
    return function_4a3d();
}

// Address range: 0x4a3d - 0x4a45
int32_t function_4a3d(void) {
    // 0x4a3d
    return function_4a46();
}

// Address range: 0x4a46 - 0x4a52
int32_t function_4a46(void) {
    int32_t result = *(int32_t *)(g2 + 16); // 0x4a46
    int32_t v1 = *(int32_t *)(result + 8); // 0x4a49
    *(int32_t *)v1 = *(int32_t *)(g2 - 32);
    *(int32_t *)(v1 + 4) = *(int32_t *)(g2 - 28);
    *(int32_t *)(v1 + 8) = *(int32_t *)(g2 - 24);
    *(int32_t *)(v1 + 12) = *(int32_t *)(g2 - 20);
    g7 = g2 - 16;
    g5 = v1 + 16;
    return result;
}

// Address range: 0x4a53 - 0x4a74
int32_t function_4a53(int32_t a1) {
    int32_t * v1 = (int32_t *)(g3 + 20); // 0x4a53_0
    *v1 = *v1 - 1;
    int32_t v2 = *(int32_t *)(g3 + 24 + 4 * *(int32_t *)(g3 + 20)); // 0x4a59
    int32_t * v3 = (int32_t *)(g3 + 8); // 0x4a5d_0
    *v3 = v2;
    memset((char *)v2, 0, (*v3 - v2) / 4);
    return 0;
}

// Address range: 0x4a75 - 0x4a7e
int32_t function_4a75(int32_t a1, int32_t a2) {
    // 0x4a75
    g3 = a2;
    return *(int32_t *)(g2 - 4);
}

// Address range: 0x4c21 - 0x4d09
int32_t _qm_KerbVerifyAccountCreationPreAuth__YGJPAVCScratchMemoryAllocator__PAUKERB_PA_DATA__PBUKERB_ENCRYPTION_KEY__PAUXKERB_TGT_CONTEXT___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // bp-8
    int32_t v2 = *(int32_t *)(a1 + 8); // 0x4c34
    *(int32_t *)(a1 + 24 + 4 * *(int32_t *)(a1 + 20)) = v2;
    int32_t * v3 = (int32_t *)(a1 + 20); // 0x4c3b_0
    *v3 = *v3 + 1;
    int32_t v4 = a2; // 0x4c43
    int32_t v5 = *(int32_t *)(v4 + 4); // 0x4c48
    int32_t v6 = *(int32_t *)(v4 + 8); // 0x4c4b
    int32_t v7 = _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(a1, v6, v5, 6, &v1, g5); // 0x4c4f
    int32_t result = v7; // edx
    int32_t * v8; // 0x4cdf_0
    int32_t * v9; // 0x4ce9_0
    int32_t v10;
    char * v11;
    uint32_t v12; // 0x4cf1
    int32_t v13; // 0x4ce2
    int32_t v14; // 0x4ce5
    if (v7 == g3) {
        // 0x4c5e
        if (*(int32_t *)(v1 + 12) == 108) {
            // 0x4c67
            if (*(int32_t *)(a4 + 56) > v7) {
                int32_t v15 = 23;
                int32_t v16 = a4 + 60; // ebx
                int32_t v17 = &a2; // 0x4c9e_0
                int32_t v18 = &v15; // 0x4ca7_0
                int32_t v19 = v7; // 0x4cce16
                // branch -> 0x4c89
                int32_t v20; // 0x4cb8
                int32_t v21; // 0x4cc1
                while (true) {
                    // 0x4c89
                    _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(g7);
                    if (_qm_KerbDecryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__PAUKERB_ENCRYPTION_KEY__KPAKPAE_Z(g7, v1, v18, 1203, v17) == 0) {
                        // 0x4cc8
                        if (a2 == 84) {
                            // 0x4cc8
                            // branch -> 0x4cce
                            // 0x4cce
                            if (v19 != *(int32_t *)(g5 + 56)) {
                                // 0x4cdd
                                // branch -> 0x4cdf
                                // 0x4cdf
                                v8 = (int32_t *)(g7 + 20);
                                *v8 = *v8 - 1;
                                v13 = g7;
                                v14 = *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20));
                                v11 = (char *)v14;
                                v9 = (int32_t *)(v13 + 8);
                                *v9 = v14;
                                v12 = *v9 - v14;
                                memset(v11, 0, v12 / 4);
                                memset(v11, 0, v12 % 4);
                                g7 = v6;
                                g3 = v5;
                                g2 = v10;
                                return 0;
                            }
                        }
                    } else {
                        // 0x4cb8
                        v20 = v19 + 1;
                        v16 += 4;
                        v21 = g5;
                        if (v20 >= *(int32_t *)(v21 + 56)) {
                            // break -> 0x4cce
                            break;
                        }
                        v19 = v20;
                        // continue -> 0x4c89
                        continue;
                    }
                    // 0x4cd6
                    // branch -> 0x4cdf
                    // 0x4cdf
                    v8 = (int32_t *)(g7 + 20);
                    *v8 = *v8 - 1;
                    v13 = g7;
                    v14 = *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20));
                    v11 = (char *)v14;
                    v9 = (int32_t *)(v13 + 8);
                    *v9 = v14;
                    v12 = *v9 - v14;
                    memset(v11, 0, v12 / 4);
                    memset(v11, 0, v12 % 4);
                    g7 = v6;
                    g3 = v5;
                    g2 = v10;
                    return -0x3fffff93;
                }
                // 0x4cce
                if (v20 != *(int32_t *)(v21 + 56)) {
                    // 0x4cdd
                    // branch -> 0x4cdf
                    // 0x4cdf
                    v8 = (int32_t *)(g7 + 20);
                    *v8 = *v8 - 1;
                    v13 = g7;
                    v14 = *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20));
                    v11 = (char *)v14;
                    v9 = (int32_t *)(v13 + 8);
                    *v9 = v14;
                    v12 = *v9 - v14;
                    memset(v11, 0, v12 / 4);
                    memset(v11, 0, v12 % 4);
                    g7 = v6;
                    g3 = v5;
                    g2 = v10;
                    return 0;
                }
            } else {
                // 0x4cce
                if (v7 != *(int32_t *)(a4 + 56)) {
                    // 0x4cdd
                    // branch -> 0x4cdf
                    // 0x4cdf
                    v8 = (int32_t *)(g7 + 20);
                    *v8 = *v8 - 1;
                    v13 = g7;
                    v14 = *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20));
                    v11 = (char *)v14;
                    v9 = (int32_t *)(v13 + 8);
                    *v9 = v14;
                    v12 = *v9 - v14;
                    memset(v11, 0, v12 / 4);
                    memset(v11, 0, v12 % 4);
                    g7 = v6;
                    g3 = v5;
                    g2 = v10;
                    return 0;
                }
            }
            // 0x4cd6
            // branch -> 0x4cdf
            // 0x4cdf
            v8 = (int32_t *)(g7 + 20);
            *v8 = *v8 - 1;
            v13 = g7;
            v14 = *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20));
            v11 = (char *)v14;
            v9 = (int32_t *)(v13 + 8);
            *v9 = v14;
            v12 = *v9 - v14;
            memset(v11, 0, v12 / 4);
            memset(v11, 0, v12 % 4);
            g7 = v6;
            g3 = v5;
            g2 = v10;
            return -0x3fffff93;
        }
        // 0x4cd6
        result = -0x3fffff93;
        // branch -> 0x4cdf
    }
    // 0x4cdf
    v8 = (int32_t *)(g7 + 20);
    *v8 = *v8 - 1;
    v13 = g7;
    v14 = *(int32_t *)(v13 + 24 + 4 * *(int32_t *)(v13 + 20));
    v11 = (char *)v14;
    v9 = (int32_t *)(v13 + 8);
    *v9 = v14;
    v12 = *v9 - v14;
    memset(v11, 0, v12 / 4);
    memset(v11, 0, v12 % 4);
    g7 = v6;
    g3 = v5;
    g2 = v10;
    return result;
}

// Address range: 0x4ef6 - 0x4fe1
int32_t _qm_KerbVerifyServiceAddressPreAuth__YGJPAVCScratchMemoryAllocator__PAUKERB_PA_DATA__PBUKERB_ENCRYPTION_KEY__PAUXKERB_SERVICE_CONTEXT__PAU_XKERB_PA_XBOX_SERVICE_ADDRESS___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a1; // esi
    int32_t v2 = 0; // bp-8
    int32_t v3 = *(int32_t *)(a1 + 8); // 0x4f09
    *(int32_t *)(a1 + 24 + 4 * *(int32_t *)(a1 + 20)) = v3;
    int32_t * v4 = (int32_t *)(v1 + 20); // 0x4f10_0
    *v4 = *v4 + 1;
    int32_t v5 = a2; // 0x4f18
    int32_t v6 = *(int32_t *)(v5 + 4); // 0x4f1d
    int32_t v7 = *(int32_t *)(v5 + 8); // 0x4f20
    int32_t v8 = _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v1, v7, v6, 6, &v2, g5); // 0x4f24
    g6 = v8;
    int32_t * v9; // 0x4fb7_0
    int32_t * v10; // 0x4fc1_0
    int32_t v11;
    char * v12;
    uint32_t v13; // 0x4fc9
    int32_t v14; // 0x4fba
    int32_t v15; // 0x4fbd
    if (v8 == g3) {
        // 0x4f33
        if (*(int32_t *)(v2 + 12) == 248) {
            // 0x4f3f
            if (*(int32_t *)(a4 + 116) > v8) {
                int32_t v16 = 23;
                int32_t v17 = a4 + 120; // ebx
                int32_t v18 = &a2; // 0x4f73_0
                int32_t v19 = &v16; // 0x4f7c_0
                int32_t v20 = v8; // 0x4fa616
                // branch -> 0x4f61
                int32_t v21; // 0x4f8d
                int32_t v22; // 0x4f96
                while (true) {
                    // 0x4f61
                    _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(g7);
                    if (_qm_KerbDecryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__PAUKERB_ENCRYPTION_KEY__KPAKPAE_Z(g7, v2, v19, 1202, v18) == 0) {
                        // 0x4f9d
                        if (a2 == 224) {
                            // 0x4f9d
                            // branch -> 0x4fa6
                            // 0x4fa6
                            if (v20 != *(int32_t *)(g5 + 116)) {
                                // 0x4fb5
                                g6 = 0;
                                // branch -> 0x4fb7
                                // 0x4fb7
                                v9 = (int32_t *)(g7 + 20);
                                *v9 = *v9 - 1;
                                v14 = g7;
                                v15 = *(int32_t *)(v14 + 24 + 4 * *(int32_t *)(v14 + 20));
                                v12 = (char *)v15;
                                v10 = (int32_t *)(v14 + 8);
                                *v10 = v15;
                                v13 = *v10 - v15;
                                memset(v12, 0, v13 / 4);
                                memset(v12, 0, v13 % 4);
                                g5 = v1;
                                g3 = v6;
                                g2 = v11;
                                return g6;
                            }
                        }
                    } else {
                        // 0x4f8d
                        v21 = v20 + 1;
                        v17 += 4;
                        v22 = g5;
                        if (v21 >= *(int32_t *)(v22 + 116)) {
                            // break -> 0x4fa6
                            break;
                        }
                        v20 = v21;
                        // continue -> 0x4f61
                        continue;
                    }
                    // 0x4fae
                    g6 = -0x3fffff93;
                    // branch -> 0x4fb7
                    // 0x4fb7
                    v9 = (int32_t *)(g7 + 20);
                    *v9 = *v9 - 1;
                    v14 = g7;
                    v15 = *(int32_t *)(v14 + 24 + 4 * *(int32_t *)(v14 + 20));
                    v12 = (char *)v15;
                    v10 = (int32_t *)(v14 + 8);
                    *v10 = v15;
                    v13 = *v10 - v15;
                    memset(v12, 0, v13 / 4);
                    memset(v12, 0, v13 % 4);
                    g5 = v1;
                    g3 = v6;
                    g2 = v11;
                    return g6;
                }
                // 0x4fa6
                if (v21 != *(int32_t *)(v22 + 116)) {
                    // 0x4fb5
                    g6 = 0;
                    // branch -> 0x4fb7
                    // 0x4fb7
                    v9 = (int32_t *)(g7 + 20);
                    *v9 = *v9 - 1;
                    v14 = g7;
                    v15 = *(int32_t *)(v14 + 24 + 4 * *(int32_t *)(v14 + 20));
                    v12 = (char *)v15;
                    v10 = (int32_t *)(v14 + 8);
                    *v10 = v15;
                    v13 = *v10 - v15;
                    memset(v12, 0, v13 / 4);
                    memset(v12, 0, v13 % 4);
                    g5 = v1;
                    g3 = v6;
                    g2 = v11;
                    return g6;
                }
            } else {
                // 0x4fa6
                if (v8 != *(int32_t *)(a4 + 116)) {
                    // 0x4fb5
                    g6 = 0;
                    // branch -> 0x4fb7
                    // 0x4fb7
                    v9 = (int32_t *)(g7 + 20);
                    *v9 = *v9 - 1;
                    v14 = g7;
                    v15 = *(int32_t *)(v14 + 24 + 4 * *(int32_t *)(v14 + 20));
                    v12 = (char *)v15;
                    v10 = (int32_t *)(v14 + 8);
                    *v10 = v15;
                    v13 = *v10 - v15;
                    memset(v12, 0, v13 / 4);
                    memset(v12, 0, v13 % 4);
                    g5 = v1;
                    g3 = v6;
                    g2 = v11;
                    return g6;
                }
            }
            // 0x4fae
            g6 = -0x3fffff93;
            // branch -> 0x4fb7
            // 0x4fb7
            v9 = (int32_t *)(g7 + 20);
            *v9 = *v9 - 1;
            v14 = g7;
            v15 = *(int32_t *)(v14 + 24 + 4 * *(int32_t *)(v14 + 20));
            v12 = (char *)v15;
            v10 = (int32_t *)(v14 + 8);
            *v10 = v15;
            v13 = *v10 - v15;
            memset(v12, 0, v13 / 4);
            memset(v12, 0, v13 % 4);
            g5 = v1;
            g3 = v6;
            g2 = v11;
            return g6;
        }
        // 0x4fae
        g6 = -0x3fffff93;
        // branch -> 0x4fb7
    }
    // 0x4fb7
    v9 = (int32_t *)(g7 + 20);
    *v9 = *v9 - 1;
    v14 = g7;
    v15 = *(int32_t *)(v14 + 24 + 4 * *(int32_t *)(v14 + 20));
    v12 = (char *)v15;
    v10 = (int32_t *)(v14 + 8);
    *v10 = v15;
    v13 = *v10 - v15;
    memset(v12, 0, v13 / 4);
    memset(v12, 0, v13 % 4);
    g5 = v1;
    g3 = v6;
    g2 = v11;
    return g6;
}

// Address range: 0x51f8 - 0x529a
int32_t _qm_KerbAddPacRequestPreAuth__YGJPAVCScratchMemoryAllocator__HPAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t a2, int32_t * a3, int32_t a4) {
    int32_t v1 = g3; // 0x5201
    int32_t * v2 = (int32_t *)(a1 + 8); // 0x5203_0
    int32_t v3 = *v2; // 0x5203
    int32_t v4 = v3; // esi
    uint32_t v5 = v3 + 16; // 0x5206
    int32_t v6 = 0; // ebx
    *v2 = v5;
    int32_t v7; // 0x5218
    if (v5 > *(int32_t *)(a1 + 4)) {
        // 0x5213
        *(int32_t *)(a1 + 8) = v4;
        v4 = 0;
        v7 = 0;
        // branch -> 0x5218
    } else {
        // 0x51f8
        v7 = v4;
        // branch -> 0x5218
    }
    // 0x5218
    int32_t v8;
    if (v7 != v6) {
        // 0x5223
        int32_t v9;
        int32_t v10 = &v9; // 0x5229_0
        v9 = 0;
        *(int32_t *)(v10 + 4) = 0;
        int32_t v11; // 0x5237_0
        if (v6 != a2) {
            // 0x5231
            int32_t v12;
            v11 = &v12;
            v9 = 128;
            v12 = v6;
            // branch -> 0x525d
        }
        // 0x525d
        if (_qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(a1, v10, 28, (int32_t *)(v4 + 8), (int32_t *)(v4 + 12), g7, v1, v11) == 0) {
            // 0x5275
            *(int32_t *)(g7 + 4) = 131;
            int32_t * v13 = (int32_t *)(int32_t)a3; // 0x527f_0
            int32_t v14 = *v13; // 0x527f
            if (v14 == g3) {
                // 0x5285
                *v13 = g7;
                // branch -> 0x5287
            } else {
                int32_t v15 = *(int32_t *)v14; // 0x529310
                if (v15 != g3) {
                    int32_t v16 = *(int32_t *)v15; // 0x5293
                    while (v16 != g3) {
                        // 0x5291
                        v15 = v16;
                        v16 = *(int32_t *)v15;
                        // continue -> 0x5291
                    }
                    // 0x5293
                    v14 = v15;
                    // branch -> 0x5297
                }
                // 0x5297
                *(int32_t *)v14 = g7;
                // branch -> 0x5287
            }
            // 0x5287
            *(int32_t *)g7 = g3;
            int32_t result = g3; // 0x528a
            // branch -> 0x5289
            // 0x5289
            g3 = v1;
            g2 = v8;
            return result;
        }
    }
    // 0x521c
    // branch -> 0x5289
    // 0x5289
    g3 = v1;
    g2 = v8;
    return -0x3fffff66;
}

// Address range: 0x541f - 0x5516
int32_t _qm_KerbAddCompoundIdentityPreAuth__YGJPAVCScratchMemoryAllocator__PAUXKERB_TGT_CONTEXT__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1;
    g2 = &v1;
    int32_t v2;
    int32_t v3 = &v2; // 0x5422_3
    g3 = a1;
    int32_t * v4 = (int32_t *)(a1 + 8); // 0x5429_0
    int32_t v5 = *v4; // 0x5429
    uint32_t v6 = v5 + 16; // 0x542d
    g7 = 0;
    int32_t v7 = g5; // bp-28
    *v4 = v6;
    int32_t v8; // 0x5475
    int32_t * v9; // 0x5463_0
    int32_t * v10; // 0x5488_0
    int32_t * v11; // 0x54d1_0
    int32_t v12; // 0x547f
    int32_t v13; // 0x54c5
    int32_t v14; // eax
    int32_t v15;
    uint32_t v16; // 0x54db
    char * v17;
    int32_t v18; // 0x547b
    int32_t v19; // 0x54c4
    uint32_t v20; // 0x54fc
    int32_t v21; // 0x5459
    int32_t v22; // 0x5488
    int32_t v23; // 0x54a8
    int32_t v24; // 0x54ce
    int32_t v25; // 0x54d4
    int32_t v26; // 0x546f
    uint32_t v27; // 0x548b
    int32_t v28; // 0x545c
    int32_t v29; // 0x5488
    int32_t v30; // 0x54b31630
    int32_t v31; // 0x54d7
    if (v6 > *(int32_t *)(a1 + 4)) {
        // 0x5449
        *(int32_t *)(g3 + 8) = v5;
        // branch -> 0x544d
        // 0x544d
        function_55a0();
        v30 = g7;
        // branch -> 0x5459
        // 0x5459
        v21 = g3;
        v28 = *(int32_t *)(v21 + 8);
        *(int32_t *)(v21 + 24 + 4 * *(int32_t *)(v21 + 20)) = v28;
        v9 = (int32_t *)(g3 + 20);
        *v9 = *v9 + 1;
        v26 = *(int32_t *)(a2 + 356);
        v8 = a2 + 360;
        v18 = g3;
        v15 = g7;
        v12 = _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v18, v8, v26, 29, &v15, v7);
        if (v12 != 0) {
            // 0x54ce
            v24 = g3;
            v11 = (int32_t *)(v24 + 20);
            *v11 = *v11 - 1;
            v25 = g3;
            v31 = *(int32_t *)(v25 + 24 + 4 * *(int32_t *)(v25 + 20));
            v17 = (char *)v31;
            v16 = *(int32_t *)(v24 + 8) - v31;
            *(int32_t *)(v25 + 8) = v31;
            memset(v17, 0, v16 / 4);
            memset(v17, 0, v16 % 4);
            return function_55a0();
        }
        // 0x5488
        v22 = g3;
        v10 = (int32_t *)(v22 + 8);
        v29 = *v10;
        v14 = v29;
        v27 = v29 + 48;
        *v10 = v27;
        if (v27 > *(int32_t *)(v22 + 4)) {
            // 0x5496
            *(int32_t *)(g3 + 8) = v14;
            v23 = 0;
            // branch -> 0x549b
        } else {
            // 0x5488
            v23 = v14;
            // branch -> 0x549b
        }
        // 0x549b
        v2 = v23;
        if (v23 != g7) {
            // 0x54a2
            memcpy((char *)(v23 + 4), (char *)v15, 11);
            *(int32_t *)v2 = 0;
            v19 = g3;
            v13 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(v19, v3, 41, (int32_t *)(v30 + 8), (int32_t *)(v30 + 12), v18, v8, v26);
            if (v13 == 0) {
                // 0x54fc
                v20 = *(int32_t *)g5;
                g5 = v20;
                if (*(int32_t *)(g3 + 16) < v20) {
                    // 0x550a
                    function_5517();
                    return v20 + 3 & -4;
                }
                // 0x5506
                g6 = 0;
                return function_5519(v19, v3, 41);
            }
        }
        // 0x54ce
        v24 = g3;
        v11 = (int32_t *)(v24 + 20);
        *v11 = *v11 - 1;
        v25 = g3;
        v31 = *(int32_t *)(v25 + 24 + 4 * *(int32_t *)(v25 + 20));
        v17 = (char *)v31;
        v16 = *(int32_t *)(v24 + 8) - v31;
        *(int32_t *)(v25 + 8) = v31;
        memset(v17, 0, v16 / 4);
        memset(v17, 0, v16 % 4);
        return function_55a0();
    }
    // 0x5449
    if (v5 != g7) {
        v30 = v5;
        // 0x5459
        v21 = g3;
        v28 = *(int32_t *)(v21 + 8);
        *(int32_t *)(v21 + 24 + 4 * *(int32_t *)(v21 + 20)) = v28;
        v9 = (int32_t *)(g3 + 20);
        *v9 = *v9 + 1;
        v26 = *(int32_t *)(a2 + 356);
        v8 = a2 + 360;
        v18 = g3;
        v15 = g7;
        v12 = _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v18, v8, v26, 29, &v15, v7);
        if (v12 == 0) {
            // 0x5488
            v22 = g3;
            v10 = (int32_t *)(v22 + 8);
            v29 = *v10;
            v14 = v29;
            v27 = v29 + 48;
            *v10 = v27;
            if (v27 > *(int32_t *)(v22 + 4)) {
                // 0x5496
                *(int32_t *)(g3 + 8) = v14;
                v23 = 0;
                // branch -> 0x549b
            } else {
                // 0x5488
                v23 = v14;
                // branch -> 0x549b
            }
            // 0x549b
            v2 = v23;
            if (v23 != g7) {
                // 0x54a2
                memcpy((char *)(v23 + 4), (char *)v15, 11);
                *(int32_t *)v2 = 0;
                v19 = g3;
                v13 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(v19, v3, 41, (int32_t *)(v30 + 8), (int32_t *)(v30 + 12), v18, v8, v26);
                if (v13 == 0) {
                    // 0x54fc
                    v20 = *(int32_t *)g5;
                    g5 = v20;
                    if (*(int32_t *)(g3 + 16) < v20) {
                        // 0x550a
                        function_5517();
                        return v20 + 3 & -4;
                    }
                    // 0x5506
                    g6 = 0;
                    return function_5519(v19, v3, 41);
                }
            }
        }
        // 0x54ce
        v24 = g3;
        v11 = (int32_t *)(v24 + 20);
        *v11 = *v11 - 1;
        v25 = g3;
        v31 = *(int32_t *)(v25 + 24 + 4 * *(int32_t *)(v25 + 20));
        v17 = (char *)v31;
        v16 = *(int32_t *)(v24 + 8) - v31;
        *(int32_t *)(v25 + 8) = v31;
        memset(v17, 0, v16 / 4);
        memset(v17, 0, v16 % 4);
        return function_55a0();
    }
    // 0x544d
    function_55a0();
    v30 = v5;
    // branch -> 0x5459
    // 0x5459
    v21 = g3;
    v28 = *(int32_t *)(v21 + 8);
    *(int32_t *)(v21 + 24 + 4 * *(int32_t *)(v21 + 20)) = v28;
    v9 = (int32_t *)(g3 + 20);
    *v9 = *v9 + 1;
    v26 = *(int32_t *)(a2 + 356);
    v8 = a2 + 360;
    v18 = g3;
    v15 = g7;
    v12 = _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v18, v8, v26, 29, &v15, v7);
    if (v12 == 0) {
        // 0x5488
        v22 = g3;
        v10 = (int32_t *)(v22 + 8);
        v29 = *v10;
        v14 = v29;
        v27 = v29 + 48;
        *v10 = v27;
        if (v27 > *(int32_t *)(v22 + 4)) {
            // 0x5496
            *(int32_t *)(g3 + 8) = v14;
            v23 = 0;
            // branch -> 0x549b
        } else {
            // 0x5488
            v23 = v14;
            // branch -> 0x549b
        }
        // 0x549b
        v2 = v23;
        if (v23 != g7) {
            // 0x54a2
            memcpy((char *)(v23 + 4), (char *)v15, 11);
            *(int32_t *)v2 = 0;
            v19 = g3;
            v13 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(v19, v3, 41, (int32_t *)(v30 + 8), (int32_t *)(v30 + 12), v18, v8, v26);
            if (v13 == 0) {
                // 0x54fc
                v20 = *(int32_t *)g5;
                g5 = v20;
                if (*(int32_t *)(g3 + 16) < v20) {
                    // 0x550a
                    function_5517();
                    return v20 + 3 & -4;
                }
                // 0x5506
                g6 = 0;
                return function_5519(v19, v3, 41);
            }
        }
    }
    // 0x54ce
    v24 = g3;
    v11 = (int32_t *)(v24 + 20);
    *v11 = *v11 - 1;
    v25 = g3;
    v31 = *(int32_t *)(v25 + 24 + 4 * *(int32_t *)(v25 + 20));
    v17 = (char *)v31;
    v16 = *(int32_t *)(v24 + 8) - v31;
    *(int32_t *)(v25 + 8) = v31;
    memset(v17, 0, v16 / 4);
    memset(v17, 0, v16 % 4);
    return function_55a0();
}

// Address range: 0x5517 - 0x5518
void function_5517(void) {
    // 0x5517
    return;
}

// Address range: 0x5519 - 0x559f
int32_t function_5519(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g6; // 0x5519
    int32_t v2 = v1; // 0x5529
    if (v1 == 0) {
        int32_t v3 = *(int32_t *)(g3 + 12); // 0x551d
        g6 = v3;
        v2 = v3;
        // branch -> 0x5520
    }
    char * v4 = (char *)*(int32_t *)g7;
    uint32_t v5 = g5; // 0x5522
    char * v6 = (char *)v2;
    memcpy(v6, v4, v5 / 4);
    memcpy(v6, v4, v5 % 4);
    int32_t * v7 = (int32_t *)(g3 + 20); // 0x5534_0
    *v7 = *v7 - 1;
    int32_t v8 = *(int32_t *)(g3 + 24 + 4 * *(int32_t *)(g3 + 20)); // 0x553a
    g5 = v8;
    int32_t * v9 = (int32_t *)(g3 + 8); // 0x553e_0
    int32_t v10 = *v9 - v8; // 0x5541
    g7 = v10;
    *v9 = v8;
    memset((char *)g5, 0, v10 / 4);
    int32_t set_mem = (int32_t)memset((char *)g5, 0, g7 % 4);
    int32_t v11; // ecx
    int32_t v12; // 0x558d
    int32_t result; // 0x558d
    if (g6 == 0) {
        // 0x558d
        memcpy((char *)g5, (char *)g7, set_mem);
        v12 = g2;
        result = *(int32_t *)(v12 + 8);
        v11 = *(int32_t *)(v12 + 16);
        *(int32_t *)(result + 4) = 130;
        *(int32_t *)result = *(int32_t *)v11;
        *(int32_t *)v11 = result;
        return result;
    }
    int32_t v13 = *(int32_t *)(g2 + 12); // 0x555a
    v11 = v13;
    int32_t * v14 = (int32_t *)(g3 + 8); // 0x555d_0
    int32_t v15 = *v14; // 0x555d
    g5 = v15;
    uint32_t v16 = v15 + (v13 + 3 & -4); // 0x5566
    *v14 = v16;
    int32_t v17; // 0x557b
    if (v16 > *(int32_t *)(g3 + 4)) {
        // 0x5570
        *(int32_t *)(g3 + 8) = g5;
        g5 = 0;
        v17 = 0;
        // branch -> 0x5575
    } else {
        // 0x555a
        v17 = g5;
        // branch -> 0x5575
    }
    // 0x5575
    *(int32_t *)(*(int32_t *)(g2 + 8) + 12) = v17;
    g7 = g6;
    memcpy((char *)g5, (char *)g6, v11 / 4);
    // branch -> 0x558d
    // 0x558d
    memcpy((char *)g5, (char *)g7, v11 % 4);
    v12 = g2;
    result = *(int32_t *)(v12 + 8);
    v11 = *(int32_t *)(v12 + 16);
    *(int32_t *)(result + 4) = 130;
    *(int32_t *)result = *(int32_t *)v11;
    *(int32_t *)v11 = result;
    return result;
}

// Address range: 0x55a0 - 0x55ac
int32_t function_55a0(void) {
    int32_t result = *(int32_t *)(g2 - 4); // 0x55a0
    g5 = *(int32_t *)(g2 - 24);
    g7 = *(int32_t *)(g2 - 20);
    g3 = *(int32_t *)(g2 - 16);
    g2 = *(int32_t *)g2;
    return result;
}

// Address range: 0x56ea - 0x5706
int32_t _qm_XkerbVerifyApReply_CXo__IAEJPAUXKERB_SERVICE_CONTEXT__PAT_LARGE_INTEGER__IPAEI2I_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g7; // 0x56f1
    g3 = 0;
    g7 = g4;
    function_5707(g5, v2);
    return 2000;
}

// Address range: 0x5707 - 0x5855
void function_5707(int32_t a1, int32_t a2) {
    int32_t v1;
    *(int32_t *)(g2 - 80) = (int32_t)&v1;
    *(int32_t *)(g2 - 84) = g5;
    *(int32_t *)(g2 - 68) = g3;
    *(int32_t *)(g2 - 76) = g5;
    *(int32_t *)(g2 - 64) = g3;
    int32_t v2;
    memset((char *)g5, (int32_t)&v2, 500);
    int32_t v3 = g2; // 0x5727
    int32_t v4 = *(int32_t *)(v3 + 32); // 0x572d
    int32_t v5 = *(int32_t *)(v3 + 28); // 0x5733
    *(int32_t *)(v3 - 72) = g3;
    int32_t v6 = v3 - 84; // bp-20
    *(int32_t *)(g2 - 28) = g7;
    if (_qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v6, v5, v4, 33, (int32_t *)(v3 - 4), v2) == 0) {
        int32_t v7 = g2; // 0x574a
        int32_t v8 = *(int32_t *)(v7 - 4); // 0x574a
        if (*(int32_t *)v8 == 5) {
            // 0x5756
            if (*(int32_t *)(v8 + 4) == 15) {
                // 0x5760
                *(int32_t *)(v7 - 16) = *(int32_t *)(v7 + 8) + 696;
                int32_t v9 = g2; // 0x5775
                int32_t v10 = v9 - 24; // 0x5775
                int32_t v11 = v9 - 84; // bp-44
                *(int32_t *)v10 = 23;
                *(int32_t *)(g2 - 20) = 16;
                if (_qm_KerbDecryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__PAUKERB_ENCRYPTION_KEY__KPAKPAE_Z(v11, v8 + 8, v10, 12, v8 + 20) != g3) {
                    // 0x5798
                    // branch -> 0x584c
                    // 0x584c
                    return;
                }
                int32_t v12 = g2; // 0x57b1
                int32_t v13 = *(int32_t *)(v12 - 4); // 0x57b5
                int32_t v14 = *(int32_t *)(v13 + 20); // 0x57ba
                int32_t v15 = *(int32_t *)(v13 + 24); // 0x57bd
                if (_qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v12 - 84, v15, v14, 34, (int32_t *)(v12 - 8), v11) == 0) {
                    int32_t v16 = g2; // 0x57d4
                    char * v17;
                    char * v18;
                    int32_t v19; // 0x582f
                    uint32_t v20; // 0x5827
                    if (*(int32_t *)(v16 + 16) != 0) {
                        // branch -> 0x57da
                        while (true) {
                            int32_t v21 = *(int32_t *)(v16 + 12); // 0x57da
                            _qm_KerbConvertLargeIntToGeneralizedTime__YGXPAUtagASN1generalizedtime_t__PAJPAT_LARGE_INTEGER___Z((int16_t *)(v16 - 24), (int32_t *)(v16 + 32), (int32_t *)v21);
                            int32_t v22 = g2; // 0x57ea
                            int32_t * v23 = (int32_t *)(v22 + 12); // 0x57f0_0
                            *v23 = *v23 + 8;
                            int32_t v24 = *(int32_t *)(v22 - 8); // 0x57f4
                            int32_t v25; // 0x580a
                            if (*(int32_t *)(v22 + 32) == *(int32_t *)(v24 + 16)) {
                                int32_t v26 = g2; // 0x57ff
                                int32_t v27 = v24 + 2; // 0x5804
                                int32_t v28 = v26 - 24; // 0x5804
                                uint16_t v29 = *(int16_t *)v28; // 0x5804
                                uint16_t v30 = *(int16_t *)v27; // 0x5804
                                int32_t v31 = v28 + 2; // 0x5804
                                g7 = v31;
                                int32_t v32 = 6; // 0x5804
                                // branch -> if_5804_0_true
                                while (v32 != 0 && ((int32_t)v29 - (int32_t)v30) % 0x10000 == 0) {
                                    // if_5804_0_true
                                    v27 += 2;
                                    v28 = v31;
                                    v29 = *(int16_t *)v28;
                                    v30 = *(int16_t *)v27;
                                    v31 = v28 + 2;
                                    g7 = v31;
                                    v32--;
                                    // continue -> if_5804_0_true
                                }
                                // after_if_5804_0
                                if (((int32_t)v29 - (int32_t)v30) % 0x10000 != 0) {
                                    v25 = v26;
                                  lab_0x5809:;
                                    int32_t v33 = g3 + 1; // 0x5809
                                    g3 = v33;
                                    if (v33 >= *(int32_t *)(v25 + 16)) {
                                        v19 = v24;
                                        v16 = v25;
                                        // break -> 0x5814
                                        break;
                                    }
                                    v16 = v25;
                                    // continue -> 0x57da
                                    continue;
                                } else {
                                    v19 = v24;
                                    v16 = v26;
                                }
                            } else {
                                // 0x57da
                                v25 = g2;
                                // branch -> 0x5809
                                goto lab_0x5809;
                            }
                            // 0x5814
                            if (g3 != *(int32_t *)(v16 + 16)) {
                                // 0x5819
                                if (*(char *)v19 != -128) {
                                    // 0x581e
                                    if (*(int32_t *)(v19 + 20) == -131) {
                                        // 0x5827
                                        v20 = *(int32_t *)(v16 + 24);
                                        if (*(int32_t *)(v19 + 24) == v20) {
                                            // 0x582f
                                            v17 = (char *)*(int32_t *)(v19 + 28);
                                            v18 = (char *)*(int32_t *)(v16 + 20);
                                            memcpy(v18, v17, v20 / 4);
                                            memcpy(v18, v17, v20 % 4);
                                            // branch -> 0x584c
                                            // 0x584c
                                            return;
                                        }
                                    }
                                }
                            }
                            // 0x5847
                            // branch -> 0x584c
                            // 0x584c
                            return;
                        }
                        // 0x5814
                        if (g3 != *(int32_t *)(v16 + 16)) {
                            // 0x5819
                            if (*(char *)v19 != -128) {
                                // 0x581e
                                if (*(int32_t *)(v19 + 20) == -131) {
                                    // 0x5827
                                    v20 = *(int32_t *)(v16 + 24);
                                    if (*(int32_t *)(v19 + 24) == v20) {
                                        // 0x582f
                                        v17 = (char *)*(int32_t *)(v19 + 28);
                                        v18 = (char *)*(int32_t *)(v16 + 20);
                                        memcpy(v18, v17, v20 / 4);
                                        memcpy(v18, v17, v20 % 4);
                                        // branch -> 0x584c
                                        // 0x584c
                                        return;
                                    }
                                }
                            }
                        }
                        // 0x5847
                        // branch -> 0x584c
                        // 0x584c
                        return;
                    }
                    // 0x5811
                    v19 = *(int32_t *)(v16 - 8);
                    // branch -> 0x5814
                    // 0x5814
                    if (g3 != *(int32_t *)(v16 + 16)) {
                        // 0x5819
                        if (*(char *)v19 != -128) {
                            // 0x581e
                            if (*(int32_t *)(v19 + 20) == -131) {
                                // 0x5827
                                v20 = *(int32_t *)(v16 + 24);
                                if (*(int32_t *)(v19 + 24) == v20) {
                                    // 0x582f
                                    v17 = (char *)*(int32_t *)(v19 + 28);
                                    v18 = (char *)*(int32_t *)(v16 + 20);
                                    memcpy(v18, v17, v20 / 4);
                                    memcpy(v18, v17, v20 % 4);
                                    // branch -> 0x584c
                                    // 0x584c
                                    return;
                                }
                            }
                        }
                    }
                    // 0x5847
                    // branch -> 0x584c
                }
                // 0x584c
                return;
            }
        }
        // 0x5847
        // branch -> 0x584c
    }
}

// Address range: 0x5a4f - 0x5ae6
int32_t _qm_KerbUnpackKdcReplyBody__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__PAUKERB_ENCRYPTION_KEY__KPAPAUKERB_ENCRYPTED_KDC_REPLY___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5) {
    int32_t v1 = (int32_t)a5;
    int32_t v2 = v1; // bp+20
    g4 = a2;
    int32_t v3 = g3; // 0x5a55
    g3 = v1;
    *a5 = 0;
    int32_t * v4 = (int32_t *)(a1 + 8); // 0x5a67_0
    int32_t v5 = *v4; // 0x5a67
    g5 = v5;
    uint32_t v6 = v5 + (*(int32_t *)(g4 + 12) + 3 & -4); // 0x5a6d
    *v4 = v6;
    int32_t v7;
    if (v6 > *(int32_t *)(a1 + 4)) {
        // 0x5a7c
        *(int32_t *)(a1 + 8) = g5;
        // branch -> 0x5a80
        // 0x5a80
        // branch -> 0x5ae0
        // 0x5ae0
        g3 = v3;
        g2 = v7;
        return 60;
    }
    // 0x5a7c
    if (g5 == 0) {
        // 0x5a80
        // branch -> 0x5ae0
        // 0x5ae0
        g3 = v3;
        g2 = v7;
        return 60;
    }
    int32_t v8 = g4; // 0x5a85
    v2 = *(int32_t *)(v8 + 12);
    int32_t v9;
    int32_t v10 = _qm_KerbDecryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__PAUKERB_ENCRYPTION_KEY__KPAKPAE_Z(a1, v8, a3, (((int32_t)&v9 & -256 | (int32_t)(a4 == 43)) ^ 1) + 7 & -245, (int32_t)&v2); // 0x5aa6
    int32_t * v11; // 0x5ad8_0
    int32_t result; // eax
    if (v10 == 0) {
        int32_t v12 = g7; // 0x5ab7
        int32_t v13 = _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v12, g5, v2, a4, (int32_t *)g3, a1); // 0x5ab8
        result = v13;
        if (v13 != 0) {
            // 0x5ac1
            int32_t v14; // 0x5acf
            if (a4 == 45) {
                // 0x5ad4
                v14 = _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(g7, g5, v2, 46, (int32_t *)g3, v12);
                result = v14;
                if (v14 == 0) {
                    // 0x5ae0
                    g3 = v3;
                    g2 = v7;
                    return 0;
                }
            } else {
                // 0x5ad4
                v14 = v13;
                // branch -> 0x5ad8
            }
            // 0x5ad8
            v11 = (int32_t *)g3;
            if (*v11 != 0) {
                // 0x5add
                *v11 = 0;
                // branch -> 0x5ae0
            } else {
                result = v14;
            }
        } else {
            result = 0;
        }
    } else {
        // 0x5ad8
        v11 = (int32_t *)g3;
        if (*v11 != 0) {
            // 0x5add
            *v11 = 0;
            result = v10;
            // branch -> 0x5ae0
        } else {
            result = v10;
        }
    }
    // 0x5ae0
    g3 = v3;
    g2 = v7;
    return result;
}

// Address range: 0x5c73 - 0x5cb1
int32_t _qm_KerbEncryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__KPAEKKPBUKERB_ENCRYPTION_KEY___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x5c73
    *(int32_t *)(a2 + 4) = 23;
    int32_t v1;
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x5c96
    int32_t v3 = *(int32_t *)(v1 + 8); // 0x5c99
    _qm_rc4HmacEncrypt__YGJPAVCScratchMemoryAllocator__PBEKKPAEK2PAK_Z(a1, v3, v2, a6, a4, a3);
    g2 = v3;
    return g7;
}

// Address range: 0x5e0b - 0x5f4a
int32_t _qm_KerbAddTimestampPreAuth__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTION_KEY__PAT_LARGE_INTEGER__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1;
    g2 = &v1;
    int32_t v2; // bp-56
    int32_t v3 = &v2; // 0x5e0e_3
    int32_t v4 = 0; // eax
    g7 = 0;
    int32_t v5 = 0; // bp-36
    int32_t v6; // bp-34
    int32_t v7 = &v6; // 0x5e1c_0
    v6 = 0;
    *(int32_t *)(v7 + 4) = 0;
    *(int32_t *)(v7 + 8) = v4;
    g3 = a1;
    *(int32_t *)(v7 + 12) = v4;
    *(int16_t *)(v7 + 16) = (int16_t)v4;
    v4 = 0;
    v2 = 0;
    *(int32_t *)(v3 + 4) = 0;
    *(int32_t *)(v3 + 8) = v4;
    *(int32_t *)(v3 + 12) = v4;
    *(int32_t *)(v3 + 16) = v4;
    int32_t v8 = g3; // 0x5e32
    int32_t * v9 = (int32_t *)(v8 + 8); // 0x5e32_0
    int32_t v10 = *v9; // 0x5e32
    uint32_t v11 = v10 + 16; // 0x5e35
    int32_t v12 = g7; // 0x5e3e
    int32_t v13 = v12;
    int32_t v14 = v12;
    *v9 = v11;
    uint32_t v15; // 0x5eb1
    int32_t * v16; // 0x5e71_0
    int32_t * v17; // 0x5ea2_0
    int32_t * v18; // 0x5f0c_0
    int32_t v19; // 0x5e96
    int32_t v20; // 0x5ee1
    int32_t v21; // 0x5ef9
    int32_t v22;
    int32_t v23; // bp-72
    uint32_t v24; // 0x5f16
    char * v25;
    int32_t v26; // 0x5ec0
    int32_t v27; // 0x5ede
    int32_t v28; // 0x5ee0
    int32_t v29; // 0x5ef8
    int32_t v30; // 0x5ed6
    uint32_t v31; // 0x5f30
    int32_t v32; // 0x5e64
    int32_t v33; // 0x5ea2
    int32_t v34; // 0x5eea
    int32_t v35; // 0x5f09
    int32_t v36; // 0x5f0f
    int32_t v37; // 0x5e67
    int32_t v38; // 0x5e9f
    int32_t v39; // 0x5ea2
    int32_t v40; // 0x5f12
    if (v11 > *(int32_t *)(v8 + 4)) {
        // 0x5e54
        *(int32_t *)(g3 + 8) = v10;
        // branch -> 0x5e58
        // 0x5e58
        function_5fd4();
        // branch -> 0x5e64
        // 0x5e64
        v32 = g3;
        v37 = *(int32_t *)(v32 + 8);
        v23 = a3;
        *(int32_t *)(v32 + 24 + 4 * *(int32_t *)(v32 + 20)) = v37;
        v16 = (int32_t *)(g3 + 20);
        *v16 = *v16 + 1;
        _qm_KerbConvertLargeIntToGeneralizedTime__YGXPAUtagASN1generalizedtime_t__PAJPAT_LARGE_INTEGER___Z((int16_t *)&v6, &v22, (int32_t *)v23);
        v5 = 128;
        v19 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(g3, (int32_t)&v5, 9, &v14, &v13, v7, (int32_t)&v22, v23);
        if (v19 != 0) {
            // 0x5f09
            v35 = g3;
            v18 = (int32_t *)(v35 + 20);
            *v18 = *v18 - 1;
            v36 = g3;
            v40 = *(int32_t *)(v36 + 24 + 4 * *(int32_t *)(v36 + 20));
            v25 = (char *)v40;
            v24 = *(int32_t *)(v35 + 8) - v40;
            *(int32_t *)(v36 + 8) = v40;
            memset(v25, 0, v24 / 4);
            memset(v25, 0, v24 % 4);
            return function_5fd4();
        }
        // 0x5e9f
        v38 = v14;
        v33 = g3;
        v17 = (int32_t *)(v33 + 8);
        v39 = *v17;
        v4 = v39;
        v15 = v39 + (v38 + 27 & -4);
        *v17 = v15;
        if (v15 > *(int32_t *)(v33 + 4)) {
            // 0x5ebb
            *(int32_t *)(g3 + 8) = v4;
            v26 = 0;
            // branch -> 0x5ec0
        } else {
            // 0x5e9f
            v26 = v4;
            // branch -> 0x5ec0
        }
        // 0x5ec0
        if (v26 != g7) {
            // 0x5ed0
            v30 = *a2;
            v27 = v38;
            v28 = g3;
            v20 = _qm_KerbEncryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__KPAEKKPBUKERB_ENCRYPTION_KEY___Z(v28, v3, v27, v13, v30, 1);
            if (v20 == 0) {
                // 0x5eea
                v34 = g5;
                v29 = g3;
                v21 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(v29, v3, 6, (int32_t *)(v34 + 8), (int32_t *)(v34 + 12), v28, v3, v27);
                if (v21 == 0) {
                    // 0x5f30
                    v31 = *(int32_t *)g5;
                    g5 = v31;
                    if (*(int32_t *)(g3 + 16) < v31) {
                        // 0x5f3e
                        function_5f4b();
                        return v31 + 3 & -4;
                    }
                    // 0x5f3a
                    g6 = 0;
                    return function_5f4d(v29, v3, 6);
                }
            }
        }
        // 0x5f09
        v35 = g3;
        v18 = (int32_t *)(v35 + 20);
        *v18 = *v18 - 1;
        v36 = g3;
        v40 = *(int32_t *)(v36 + 24 + 4 * *(int32_t *)(v36 + 20));
        v25 = (char *)v40;
        v24 = *(int32_t *)(v35 + 8) - v40;
        *(int32_t *)(v36 + 8) = v40;
        memset(v25, 0, v24 / 4);
        memset(v25, 0, v24 % 4);
        return function_5fd4();
    }
    // 0x5e54
    if (v10 != g7) {
        // 0x5e64
        v32 = g3;
        v37 = *(int32_t *)(v32 + 8);
        v23 = a3;
        *(int32_t *)(v32 + 24 + 4 * *(int32_t *)(v32 + 20)) = v37;
        v16 = (int32_t *)(g3 + 20);
        *v16 = *v16 + 1;
        _qm_KerbConvertLargeIntToGeneralizedTime__YGXPAUtagASN1generalizedtime_t__PAJPAT_LARGE_INTEGER___Z((int16_t *)&v6, &v22, (int32_t *)v23);
        v5 = 128;
        v19 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(g3, (int32_t)&v5, 9, &v14, &v13, v7, (int32_t)&v22, v23);
        if (v19 == 0) {
            // 0x5e9f
            v38 = v14;
            v33 = g3;
            v17 = (int32_t *)(v33 + 8);
            v39 = *v17;
            v4 = v39;
            v15 = v39 + (v38 + 27 & -4);
            *v17 = v15;
            if (v15 > *(int32_t *)(v33 + 4)) {
                // 0x5ebb
                *(int32_t *)(g3 + 8) = v4;
                v26 = 0;
                // branch -> 0x5ec0
            } else {
                // 0x5e9f
                v26 = v4;
                // branch -> 0x5ec0
            }
            // 0x5ec0
            if (v26 != g7) {
                // 0x5ed0
                v30 = *a2;
                v27 = v38;
                v28 = g3;
                v20 = _qm_KerbEncryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__KPAEKKPBUKERB_ENCRYPTION_KEY___Z(v28, v3, v27, v13, v30, 1);
                if (v20 == 0) {
                    // 0x5eea
                    v34 = g5;
                    v29 = g3;
                    v21 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(v29, v3, 6, (int32_t *)(v34 + 8), (int32_t *)(v34 + 12), v28, v3, v27);
                    if (v21 == 0) {
                        // 0x5f30
                        v31 = *(int32_t *)g5;
                        g5 = v31;
                        if (*(int32_t *)(g3 + 16) < v31) {
                            // 0x5f3e
                            function_5f4b();
                            return v31 + 3 & -4;
                        }
                        // 0x5f3a
                        g6 = 0;
                        return function_5f4d(v29, v3, 6);
                    }
                }
            }
        }
        // 0x5f09
        v35 = g3;
        v18 = (int32_t *)(v35 + 20);
        *v18 = *v18 - 1;
        v36 = g3;
        v40 = *(int32_t *)(v36 + 24 + 4 * *(int32_t *)(v36 + 20));
        v25 = (char *)v40;
        v24 = *(int32_t *)(v35 + 8) - v40;
        *(int32_t *)(v36 + 8) = v40;
        memset(v25, 0, v24 / 4);
        memset(v25, 0, v24 % 4);
        return function_5fd4();
    }
    // 0x5e58
    function_5fd4();
    // branch -> 0x5e64
    // 0x5e64
    v32 = g3;
    v37 = *(int32_t *)(v32 + 8);
    v23 = a3;
    *(int32_t *)(v32 + 24 + 4 * *(int32_t *)(v32 + 20)) = v37;
    v16 = (int32_t *)(g3 + 20);
    *v16 = *v16 + 1;
    _qm_KerbConvertLargeIntToGeneralizedTime__YGXPAUtagASN1generalizedtime_t__PAJPAT_LARGE_INTEGER___Z((int16_t *)&v6, &v22, (int32_t *)v23);
    v5 = 128;
    v19 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(g3, (int32_t)&v5, 9, &v14, &v13, v7, (int32_t)&v22, v23);
    if (v19 == 0) {
        // 0x5e9f
        v38 = v14;
        v33 = g3;
        v17 = (int32_t *)(v33 + 8);
        v39 = *v17;
        v4 = v39;
        v15 = v39 + (v38 + 27 & -4);
        *v17 = v15;
        if (v15 > *(int32_t *)(v33 + 4)) {
            // 0x5ebb
            *(int32_t *)(g3 + 8) = v4;
            v26 = 0;
            // branch -> 0x5ec0
        } else {
            // 0x5e9f
            v26 = v4;
            // branch -> 0x5ec0
        }
        // 0x5ec0
        if (v26 != g7) {
            // 0x5ed0
            v30 = *a2;
            v27 = v38;
            v28 = g3;
            v20 = _qm_KerbEncryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__KPAEKKPBUKERB_ENCRYPTION_KEY___Z(v28, v3, v27, v13, v30, 1);
            if (v20 == 0) {
                // 0x5eea
                v34 = g5;
                v29 = g3;
                v21 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(v29, v3, 6, (int32_t *)(v34 + 8), (int32_t *)(v34 + 12), v28, v3, v27);
                if (v21 == 0) {
                    // 0x5f30
                    v31 = *(int32_t *)g5;
                    g5 = v31;
                    if (*(int32_t *)(g3 + 16) < v31) {
                        // 0x5f3e
                        function_5f4b();
                        return v31 + 3 & -4;
                    }
                    // 0x5f3a
                    g6 = 0;
                    return function_5f4d(v29, v3, 6);
                }
            }
        }
    }
    // 0x5f09
    v35 = g3;
    v18 = (int32_t *)(v35 + 20);
    *v18 = *v18 - 1;
    v36 = g3;
    v40 = *(int32_t *)(v36 + 24 + 4 * *(int32_t *)(v36 + 20));
    v25 = (char *)v40;
    v24 = *(int32_t *)(v35 + 8) - v40;
    *(int32_t *)(v36 + 8) = v40;
    memset(v25, 0, v24 / 4);
    memset(v25, 0, v24 % 4);
    return function_5fd4();
}

// Address range: 0x5f4b - 0x5f4c
void function_5f4b(void) {
    // 0x5f4b
    return;
}

// Address range: 0x5f4d - 0x5fd3
int32_t function_5f4d(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g6; // 0x5f4d
    int32_t v2 = v1; // 0x5f5d
    if (v1 == 0) {
        int32_t v3 = *(int32_t *)(g3 + 12); // 0x5f51
        g6 = v3;
        v2 = v3;
        // branch -> 0x5f54
    }
    char * v4 = (char *)*(int32_t *)g7;
    char * v5 = (char *)v2;
    memcpy(v5, v4, g5 / 4);
    memcpy(v5, v4, g5 % 4);
    int32_t * v6 = (int32_t *)(g3 + 20); // 0x5f68_0
    *v6 = *v6 - 1;
    int32_t v7 = *(int32_t *)(g3 + 24 + 4 * *(int32_t *)(g3 + 20)); // 0x5f6e
    int32_t v8 = v7; // edi
    int32_t * v9 = (int32_t *)(g3 + 8); // 0x5f72_0
    int32_t v10 = *v9 - v7; // 0x5f75
    *v9 = v7;
    memset((char *)v8, 0, v10 / 4);
    int32_t set_mem = (int32_t)memset((char *)v8, 0, v10 % 4);
    int32_t v11; // ecx
    int32_t v12; // 0x5fc1
    int32_t result; // 0x5fc1
    if (g6 == 0) {
        // 0x5fc1
        memcpy((char *)v8, (char *)v10, set_mem);
        v12 = g2;
        result = *(int32_t *)(v12 + 8);
        v11 = *(int32_t *)(v12 + 20);
        *(int32_t *)(result + 4) = 2;
        *(int32_t *)result = *(int32_t *)v11;
        *(int32_t *)v11 = result;
        return result;
    }
    int32_t v13 = *(int32_t *)(g2 + 16); // 0x5f8e
    v11 = v13;
    int32_t * v14 = (int32_t *)(g3 + 8); // 0x5f91_0
    int32_t v15 = *v14; // 0x5f91
    v8 = v15;
    uint32_t v16 = v15 + (v13 + 3 & -4); // 0x5f9a
    *v14 = v16;
    int32_t v17; // 0x5faf
    if (v16 > *(int32_t *)(g3 + 4)) {
        // 0x5fa4
        *(int32_t *)(g3 + 8) = v8;
        v8 = 0;
        v17 = 0;
        // branch -> 0x5fa9
    } else {
        // 0x5f8e
        v17 = v8;
        // branch -> 0x5fa9
    }
    // 0x5fa9
    *(int32_t *)(*(int32_t *)(g2 + 8) + 12) = v17;
    memcpy((char *)v8, (char *)g6, v11 / 4);
    // branch -> 0x5fc1
    // 0x5fc1
    memcpy((char *)v8, (char *)g6, v11 % 4);
    v12 = g2;
    result = *(int32_t *)(v12 + 8);
    v11 = *(int32_t *)(v12 + 20);
    *(int32_t *)(result + 4) = 2;
    *(int32_t *)result = *(int32_t *)v11;
    *(int32_t *)v11 = result;
    return result;
}

// Address range: 0x5fd4 - 0x5fe0
int32_t function_5fd4(void) {
    int32_t result = *(int32_t *)(g2 - 4); // 0x5fd4
    g7 = *(int32_t *)(g2 - 60);
    g3 = *(int32_t *)(g2 - 56);
    g2 = *(int32_t *)g2;
    return result;
}

// Address range: 0x6160 - 0x617e
int32_t _qm_KerbAddXboxServiceRequestPreAuth__YGJPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__PBUXKERB_TGT_CONTEXT__KPBUXKERB_SERVICE_CONTEXT__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(int32_t a1, int32_t a2) {
    int32_t v1;
    g2 = &v1;
    int32_t v2; // bp-60
    int32_t v3 = &v2; // 0x6163_3
    int32_t v4 = 0; // eax
    v2 = 0;
    *(int32_t *)(v3 + 4) = 0;
    *(int32_t *)(v3 + 8) = v4;
    *(int32_t *)(v3 + 12) = v4;
    *(int32_t *)(v3 + 16) = v4;
    return function_617f(g5, g7, g3, v2, 0, 0, 0);
}

// Address range: 0x617f - 0x62fd
int32_t function_617f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    g3 = *(int32_t *)(g2 + 8);
    int32_t v1;
    memset((char *)&v1, 0, 27);
    int32_t v2 = g3; // 0x618d
    int32_t v3 = *(int32_t *)(v2 + 8); // 0x618d
    int32_t v4 = v3; // ecx
    int32_t v5 = v3 + 16; // 0x6190
    *(int32_t *)(g2 - 8) = (int32_t)&v1;
    *(int32_t *)(g2 + 8) = v4;
    *(int32_t *)(g3 + 8) = v5;
    int32_t v6; // 0x61ab
    if (v5 > *(int32_t *)(v2 + 4)) {
        // 0x61a1
        *(int32_t *)(g2 + 8) = 0;
        *(int32_t *)(g3 + 8) = v4;
        v6 = *(int32_t *)(g2 + 8);
        // branch -> 0x61ab
    } else {
        // 0x61ab
        v6 = v4;
        // branch -> 0x61ab
    }
    // 0x61ab
    if (v6 == 0) {
        // 0x61af
        *(int32_t *)(g2 - 4) = -0x3fffff66;
        return function_6387();
    }
    int32_t v7 = g3; // 0x61bb
    int32_t v8 = *(int32_t *)(v7 + 8); // 0x61be
    *(int32_t *)(v7 + 24 + 4 * *(int32_t *)(v7 + 20)) = v8;
    int32_t * v9 = (int32_t *)(g3 + 20); // 0x61c5_0
    *v9 = *v9 + 1;
    v1 = 1;
    int32_t v10 = &a6; // 0x61ff_0
    v4 = v10;
    int32_t v11 = *(int32_t *)(g2 + 16) + 8; // 0x6202
    *(int32_t *)v10 = *(int32_t *)v11;
    *(int32_t *)(v4 + 4) = *(int32_t *)(v11 + 4);
    int32_t v12 = v4 + 8; // 0x6213
    v4 = v12;
    int32_t v13 = 3; // 0x6216
    // branch -> 0x6206
    while (v13 != 0) {
        // 0x6206
        v11 += 8;
        *(int32_t *)v12 = *(int32_t *)v11;
        *(int32_t *)(v4 + 4) = *(int32_t *)(v11 + 4);
        v12 = v4 + 8;
        v4 = v12;
        v13--;
        // continue -> 0x6206
    }
    // 0x6219
    int32_t v14;
    memcpy((char *)&v14, (char *)(*(int32_t *)(g2 + 24) + 52), 12);
    _qm_KerbComputeKdcRequestNonceHmacKey__YGXPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAE_Z(g3);
    int32_t v15 = g2; // 0x623d
    *(int32_t *)(v15 - 12) = v15 - 36;
    int32_t v16 = g3; // 0x6243
    int32_t v17 = *(int32_t *)(v16 + 8); // 0x6243
    v11 = v17;
    int32_t v18 = v17 + 132; // 0x6248
    *(int32_t *)(g2 - 20) = 23;
    *(int32_t *)(g2 - 16) = 16;
    *(int32_t *)(g2 - 44) = 132;
    *(int32_t *)(g3 + 8) = v18;
    int32_t v19; // 0x626f
    if (v18 > *(int32_t *)(v16 + 4)) {
        // 0x6268
        *(int32_t *)(g3 + 8) = v11;
        v19 = 0;
        // branch -> 0x626d
    } else {
        // 0x6219
        v19 = v11;
        // branch -> 0x626d
    }
    // 0x626d
    *(int32_t *)(g2 - 40) = v19;
    int32_t v20 = g2; // 0x6274
    if (v19 == 0) {
        // 0x6274
        *(int32_t *)(v20 - 4) = -0x5000ffc4;
        // branch -> 0x62bc
    } else {
        int32_t v21 = *(int32_t *)(v20 - 8); // 0x6287
        int32_t v22 = v20 - 56; // 0x628a
        int32_t v23 = g3; // 0x6290
        if (_qm_KerbEncryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__KPAEKKPBUKERB_ENCRYPTION_KEY___Z(v23, v22, 108, v21, 23, 1201) == 0) {
            int32_t v24 = g2; // 0x629a
            int32_t v25 = *(int32_t *)(v24 + 8); // 0x629a
            int32_t v26 = v24 - 56; // 0x62a7
            int32_t v27 = g3; // 0x62ab
            if (_qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(v27, v26, 6, (int32_t *)(v25 + 8), (int32_t *)(v25 + 12), v23, v22, 108) == 0) {
                uint32_t v28 = *(int32_t *)g5; // 0x62e3
                g5 = v28;
                *(int32_t *)(g2 + 16) = v28;
                if (*(int32_t *)(g3 + 16) < v28) {
                    // 0x62f1
                    function_62fe();
                    return g5 + 3 & -4;
                }
                // 0x62ed
                g6 = 0;
                return function_6300(v27, v26, 6);
            }
        }
        // 0x62b5
        *(int32_t *)(g2 - 4) = -0x3fffff66;
        // branch -> 0x62bc
    }
    int32_t * v29 = (int32_t *)(g3 + 20); // 0x62bf_0
    *v29 = *v29 - 1;
    int32_t v30 = *(int32_t *)(g3 + 24 + 4 * *(int32_t *)(g3 + 20)); // 0x62c5
    char * v31 = (char *)v30;
    uint32_t v32 = *(int32_t *)(g3 + 8) - v30; // 0x62c9
    *(int32_t *)(g3 + 8) = v30;
    memset(v31, 0, v32 / 4);
    memset(v31, 0, v32 % 4);
    return function_6387();
}

// Address range: 0x62fe - 0x62ff
void function_62fe(void) {
    // 0x62fe
    return;
}

// Address range: 0x6300 - 0x6386
int32_t function_6300(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g6; // 0x6300
    int32_t v2 = v1; // 0x6310
    if (v1 == 0) {
        int32_t v3 = *(int32_t *)(g3 + 12); // 0x6304
        g6 = v3;
        v2 = v3;
        // branch -> 0x6307
    }
    char * v4 = (char *)*(int32_t *)g7;
    char * v5 = (char *)v2;
    memcpy(v5, v4, g5 / 4);
    memcpy(v5, v4, g5 % 4);
    int32_t * v6 = (int32_t *)(g3 + 20); // 0x631b_0
    *v6 = *v6 - 1;
    int32_t v7 = *(int32_t *)(g3 + 24 + 4 * *(int32_t *)(g3 + 20)); // 0x6321
    int32_t v8 = v7; // edi
    int32_t * v9 = (int32_t *)(g3 + 8); // 0x6325_0
    int32_t v10 = *v9 - v7; // 0x6328
    *v9 = v7;
    memset((char *)v8, 0, v10 / 4);
    int32_t set_mem = (int32_t)memset((char *)v8, 0, v10 % 4);
    int32_t v11; // ecx
    int32_t v12; // 0x6374
    int32_t result; // 0x6374
    if (g6 == 0) {
        // 0x6374
        memcpy((char *)v8, (char *)v10, set_mem);
        v12 = g2;
        result = *(int32_t *)(v12 + 8);
        v11 = *(int32_t *)(v12 + 28);
        *(int32_t *)(result + 4) = 201;
        *(int32_t *)result = *(int32_t *)v11;
        *(int32_t *)v11 = result;
        return result;
    }
    int32_t v13 = *(int32_t *)(g2 + 16); // 0x6341
    v11 = v13;
    int32_t * v14 = (int32_t *)(g3 + 8); // 0x6344_0
    int32_t v15 = *v14; // 0x6344
    v8 = v15;
    uint32_t v16 = v15 + (v13 + 3 & -4); // 0x634d
    *v14 = v16;
    int32_t v17; // 0x6362
    if (v16 > *(int32_t *)(g3 + 4)) {
        // 0x6357
        *(int32_t *)(g3 + 8) = v8;
        v8 = 0;
        v17 = 0;
        // branch -> 0x635c
    } else {
        // 0x6341
        v17 = v8;
        // branch -> 0x635c
    }
    // 0x635c
    *(int32_t *)(*(int32_t *)(g2 + 8) + 12) = v17;
    memcpy((char *)v8, (char *)g6, v11 / 4);
    // branch -> 0x6374
    // 0x6374
    memcpy((char *)v8, (char *)g6, v11 % 4);
    v12 = g2;
    result = *(int32_t *)(v12 + 8);
    v11 = *(int32_t *)(v12 + 28);
    *(int32_t *)(result + 4) = 201;
    *(int32_t *)result = *(int32_t *)v11;
    *(int32_t *)v11 = result;
    return result;
}

// Address range: 0x6387 - 0x6393
int32_t function_6387(void) {
    int32_t result = *(int32_t *)(g2 - 4); // 0x6387
    g2 = *(int32_t *)g2;
    return result;
}

// Address range: 0x6561 - 0x657a
int32_t _qm_XkerbBuildAsRequest_CXo__IAEJHPAUXONLINEP_USER__PAEPAKPAUXKERB_TGT_CONTEXT___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1;
    g2 = &v1;
    g3 = g4;
    function_657b(g5);
    return 2000;
}

// Address range: 0x657b - 0x66fb
void function_657b(int32_t a1) {
    int32_t v1 = g2; // 0x657b
    *(int32_t *)(v1 + 16) = 0;
    *(int32_t *)(g2 + 20) = 0;
    int32_t v2;
    int32_t v3 = &v2; // 0x6588_0
    int32_t v4;
    *(int32_t *)(g2 + 4) = (int32_t)&v4;
    *(int32_t *)g2 = v3;
    *(int32_t *)(g2 + 8) = v3;
    memset((char *)&v2, v3, 500);
    int32_t v5 = g2; // 0x65a2
    int32_t v6 = *(int32_t *)(v5 + 116); // 0x65a2
    *(int32_t *)(v5 + 12) = v6;
    if (v6 != 0) {
        // 0x65ac
        *(int32_t *)(g2 + 16) = *(int32_t *)*(int32_t *)(v1 + 120);
        // branch -> 0x65af
    }
    // 0x65af
    memset((char *)(g2 - 136), 0, 32);
    *(int32_t *)(g2 - 124) = 0;
    int32_t v7 = g2; // 0x65bf
    *(int32_t *)(v7 + 56) = g3;
    int32_t v8 = g2; // 0x65c5
    int32_t v9 = *(int32_t *)(v8 + 124); // 0x65c5
    g3 = v9;
    int32_t v10 = *(int32_t *)(v9 + 168); // 0x65c8
    int32_t v11 = *(int32_t *)(v7 + 112) + 80; // esi
    *(int32_t *)(v8 + 80) = 23;
    *(int32_t *)(g2 + 84) = 16;
    *(int32_t *)(g2 + 76) = v11;
    *(int32_t *)(g2 + 88) = v11;
    int32_t v12 = g3; // 0x6613
    int32_t v13; // 0x65f7
    if (v10 == 0) {
        // 0x6613
        *(int32_t *)(v12 + 108) = *(int32_t *)v11;
        *(int32_t *)(v12 + 112) = *(int32_t *)(v11 + 4);
        *(int32_t *)(v12 + 116) = *(int32_t *)(v11 + 8);
        *(int32_t *)(v12 + 120) = *(int32_t *)(v11 + 12);
        g7 = v11 + 16;
        g5 = *(int32_t *)(g2 + 112);
        // branch -> 0x661d
    } else {
        int32_t v14 = g2 + 80; // 0x65ee
        _qm_KerbComputeCompoundIdentityKey__YGXPBUKERB_ENCRYPTION_KEY__PBUXKERB_TGT_CONTEXT__PAE_Z(v14);
        v13 = g2;
        int32_t v15 = *(int32_t *)(g3 + 168); // 0x65fb
        if (_qm_KerbAddCompoundIdentityPreAuth__YGJPAVCScratchMemoryAllocator__PAUXKERB_TGT_CONTEXT__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(v13, v15, v13 - 124, v14, v10) <= 0xffffffff) {
            // 0x660e
            function_6808(v13, v15);
            return;
        }
        // 0x65e9
        // branch -> 0x661d
    }
    // 0x661d
    *(int32_t *)(g2 + 68) = g3 + 108;
    int32_t v16 = g2; // 0x6623
    *(int32_t *)(v16 + 60) = 23;
    *(int32_t *)(g2 + 64) = 16;
    _qm_KerbAddPacRequestPreAuth__YGJPAVCScratchMemoryAllocator__HPAPAUKERB_KDC_REQUEST_preauth_data_s___Z(v16, 1, (int32_t *)(v16 - 124), v13);
    int32_t v17 = g2 - 8; // 0x6648
    _qm_KerbGetCurrentTime__YGXPAT_LARGE_INTEGER___Z(v17, v16);
    int32_t v18 = g2; // 0x6651
    int32_t v19 = v18 + 60; // 0x6659
    _qm_KerbAddTimestampPreAuth__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTION_KEY__PAT_LARGE_INTEGER__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(v18, (int32_t *)v19, v18 - 8, v18 - 124, v17, v16);
    int32_t v20 = g2; // 0x666e
    int32_t v21 = *(int32_t *)(v20 - 44); // 0x6672
    _qm_KerbAddClientVersionPreAuth__YGJPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAPAUKERB_KDC_REQUEST_preauth_data_s___Z(v20, v20 + 80, v21, v20 - 124, v18, v19);
    int32_t v22 = g2; // 0x668a
    int32_t v23 = v22 + 80; // 0x668e
    int32_t v24 = g5 + 12; // 0x6692
    _qm_KerbAddPrePreAuth__YGJPAVCScratchMemoryAllocator__PADPAUKERB_ENCRYPTION_KEY__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(v22, (char *)v24, v23, v22 - 124, v20);
    int32_t v25 = *(int32_t *)(g3 + 124); // 0x66a7
    if (v25 != 0) {
        int32_t v26 = g2; // 0x66ae
        int32_t v27 = g3 + 128; // 0x66b2
        g4 = v27;
        _qm_KerbAddEchoPreAuth__YGJPAVCScratchMemoryAllocator__KPAEPAPAUKERB_KDC_REQUEST_preauth_data_s___Z(v26, v25, (char *)v27, (int32_t *)(v26 - 124), v22, v24, v23);
        // branch -> 0x66cb
    }
    int32_t v28 = g2; // 0x66cb
    if (*(int32_t *)(v28 - 124) != 0) {
        char * v29 = (char *)(v28 - 136); // 0x66d1_0
        *v29 = *v29 | -128;
        // branch -> 0x66d8
    }
    // 0x66d8
    *(int32_t *)(g8 - 4) = 0x10000;
    *(int32_t *)(g8 - 8) = 0x66e2;
    int32_t v30 = _qm_KerbConvertUlongToFlagUlong__YGKK_Z(a1, 0, 0, 0, 0); // 0x66dd
    int32_t * v31 = (int32_t *)(g8 - 4); // 0x66e2_0
    *v31 = 32;
    *(int32_t *)(g2 + 72) = v30;
    int32_t v32 = *v31; // 0x66e7
    g7 = v32;
    int32_t v33 = g2; // 0x66e8
    *(int32_t *)(v33 - 112) = v33 + 72;
    *v31 = 4;
    *(int32_t *)(g8 - 8) = g2 - 44;
    *(int32_t *)(g2 - 116) = v32;
    *(int32_t *)(g8 - 12) = (int32_t)&g9;
    function_66fc(a1);
}

// Address range: 0x66fc - 0x672b
void function_66fc(int32_t a1) {
    // 0x66fc
    _qm_KerbConvertLargeIntToGeneralizedTime__YGXPAUtagASN1generalizedtime_t__PAJPAT_LARGE_INTEGER___Z((int16_t *)(g2 - 74), NULL, &g11);
    int32_t v1 = g2 - 200; // 0x671e
    g1 = v1;
    function_672c(v1, 64, (int32_t)"%s@%s", g5 + 12);
}

// Address range: 0x672c - 0x6749
void function_672c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x672c
    function_6808(0, a1);
}

// Address range: 0x674a - 0x675b
void function_674a(int32_t a1) {
    int32_t v1 = g2 - 200; // 0x674f
    g1 = v1;
    function_675c(v1, g7);
}

// Address range: 0x675c - 0x67a0
void function_675c(int32_t a1, int32_t a2) {
    int32_t v1 = g2; // 0x6763
    int32_t v2 = _qm_KerbConstructPrincipalName__YGJPAVCScratchMemoryAllocator__PAUKERB_PRINCIPAL_NAME__KPAD2_Z(v1, (int32_t *)(v1 - 108), 10, v1 - 200, g1); // 0x6774
    char * v3 = (char *)(g2 - 120); // 0x6781_0
    *v3 = *v3 | -128;
    g7 = (int32_t)"XBOX.COM";
    if (*(int32_t *)(g2 + 108) == v2) {
        // 0x678f
        g7 = g5 + 56;
        // branch -> 0x6792
    }
    // 0x6792
    function_67a1(g3 + 264);
}

// Address range: 0x67a1 - 0x6807
void function_67a1(int32_t a1) {
    int32_t v1 = g2; // 0x67a9
    int32_t v2 = v1 - 96; // 0x67a9
    int32_t v3;
    _qm_KerbConstructPrincipalName__YGJPAVCScratchMemoryAllocator__PAUKERB_PRINCIPAL_NAME__KPAD2_Z(v1, (int32_t *)v2, 2, (int32_t)"krbtgt", v3);
    int32_t v4 = g2; // 0x67ba
    char * v5 = (char *)(v4 - 120); // 0x67bd_0
    *v5 = *v5 | 64;
    *(int32_t *)(g2 - 100) = g5 + 56;
    *(int32_t *)(g2 + 92) = *(int32_t *)*(int32_t *)(v4 + 120);
    int32_t v6 = g2; // 0x67cc
    *(int32_t *)(v6 + 96) = *(int32_t *)(v6 + 116);
    int32_t v7 = g2; // 0x67d2
    *(int32_t *)(v7 - 132) = 5;
    *(int32_t *)(g2 - 128) = 10;
    *(int32_t *)(g2 - 40) = 2772;
    _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(v7, v7 - 136, 48, (int32_t *)(v7 + 92), (int32_t *)(v7 + 96), v1, v2, 2);
}

// Address range: 0x6808 - 0x689a
int32_t function_6808(int32_t a1, int32_t a2) {
    // 0x6808
    return -0x3fffff66;
}

// Address range: 0x6ae3 - 0x6b08
int32_t _qm_XkerbVerifyAsReply_CXo__IAEJPAEKPAUXKERB_TGT_CONTEXT___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g7; // 0x6aea
    g7 = 0;
    g3 = g4;
    function_6b09(g5, v2);
    return 2000;
}

// Address range: 0x6b09 - 0x6c1c
void function_6b09(int32_t a1, int32_t a2) {
    int32_t v1;
    *(int32_t *)(g2 - 92) = (int32_t)&v1;
    *(int32_t *)(g2 - 96) = g5;
    *(int32_t *)(g2 - 80) = g7;
    *(int32_t *)(g2 - 88) = g5;
    *(int32_t *)(g2 - 76) = g7;
    int32_t v2;
    memset((char *)g5, (int32_t)&v2, 500);
    int32_t v3 = g2; // 0x6b29
    int32_t v4 = *(int32_t *)(v3 + 12); // bp-12
    int32_t v5 = *(int32_t *)(v3 + 8); // 0x6b35
    *(int32_t *)(v3 - 84) = g7;
    int32_t v6 = v3 - 96; // bp-20
    *(int32_t *)(g2 - 40) = g3;
    _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v6, v5, v4, 43, (int32_t *)(v3 - 8), v2);
    int32_t v7 = g2; // 0x6b4c
    int32_t v8 = *(int32_t *)(v7 + 12); // 0x6b52
    int32_t v9 = *(int32_t *)(v7 + 8); // 0x6b58
    _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v7 - 96, v9, v8, 5, (int32_t *)(v7 - 16), v6);
    int32_t v10 = g2; // 0x6b69
    int32_t v11 = *(int32_t *)(v10 - 16); // 0x6b69
    int32_t v12 = *(int32_t *)(v11 + 52); // 0x6b6c
    int32_t v13 = *(int32_t *)(v10 + 16); // 0x6b6f
    g5 = *(int32_t *)(v13 + 56);
    *(int32_t *)(v10 + 8) = v12;
    int32_t v14 = v12 | -0x50010000; // 0x6b78
    *(int32_t *)(g2 - 4) = v14;
    int32_t v15 = g5; // 0x6b84
    g7 = v15;
    int32_t v16 = v15; // 0x6bb4
    int32_t v17 = v15; // 0x6bb4
    int32_t v18;
    int32_t v19;
    int32_t v20;
    int32_t v21; // 0x6bbc
    int32_t v22; // 0x6bd6
    int32_t v23; // 0x6bdc
    int32_t v24; // 0x6bfa
    int32_t v25; // 0x6bc1
    uint32_t v26; // 0x6bd6
    int32_t v27; // 0x6bd9
    int32_t v28; // 0x6bfa
    if (*(char *)v11 != 8) {
        // 0x6b88
        if (*(int32_t *)(v11 + 80) == 4) {
            int32_t v29 = *(int32_t *)(v11 + 84); // 0x6b8e
            if (v29 == 0) {
                v16 = v15;
                v17 = v15;
                // 0x6bb4
                v21 = v11;
                if (*(char *)v21 == 4) {
                    // 0x6bb4
                    v18 = v29;
                    v19 = v17;
                    v20 = v16;
                    // branch -> 0x6bf0
                } else {
                    // 0x6bc1
                    v25 = *(int32_t *)(v21 + 88);
                    if (v25 != 0) {
                        // 0x6bc8
                        if (*(int32_t *)(v21 + 92) != 0) {
                            // 0x6bce
                            if (v25 <= 40) {
                                // 0x6bd3
                                *(int32_t *)(v13 + 124) = v25;
                                v22 = v11;
                                v26 = *(int32_t *)(v22 + 88);
                                v27 = *(int32_t *)(v22 + 92);
                                g7 = v27;
                                v23 = v13 + 128;
                                g5 = v23;
                                memcpy((char *)v23, (char *)v27, v26 / 4);
                                v18 = v26 % 4;
                                v19 = g7;
                                v20 = g5;
                                // branch -> 0x6bf0
                            } else {
                                v18 = v25;
                                v19 = v17;
                                v20 = v16;
                            }
                        } else {
                            v18 = v25;
                            v19 = v17;
                            v20 = v16;
                        }
                    } else {
                        v18 = 0;
                        v19 = v17;
                        v20 = v16;
                    }
                }
                // 0x6bf0
                memcpy((char *)v20, (char *)v19, v18);
                v24 = v11;
                v28 = *(int32_t *)(v24 + 48);
                _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g2 - 32), (int16_t *)(v24 + 32), v28);
                _qm_KerbUpdateCurrentTime__YGXT_LARGE_INTEGER___Z();
                function_6c1d();
                return;
            }
            // 0x6b95
            g7 = 0;
            if (v15 != 0) {
                // 0x6b9b
                *(int32_t *)(g2 + 12) = v13 + 60;
                // branch -> 0x6ba1
                int32_t v30; // 0x6bae
                while (true) {
                    int32_t * v31 = (int32_t *)(g2 + 12); // 0x6ba1_0
                    if (*(int32_t *)*v31 == *(int32_t *)v29) {
                        // 0x6ba1
                        // branch -> 0x6bb4
                    } else {
                        // 0x6baa
                        *v31 = *v31 + 4;
                        v30 = g7 + 1;
                        g7 = v30;
                        if (v30 >= *(int32_t *)(v13 + 56)) {
                            // break -> 0x6bb4
                            break;
                        }
                        // continue -> 0x6ba1
                        continue;
                    }
                    // 0x6bb4
                    // branch -> 0x6bb4
                }
                // 0x6bb4
                // branch -> 0x6bb4
                // 0x6bb4
                v16 = g5;
                v17 = v30;
                // branch -> 0x6bb4
            } else {
                v16 = 0;
                v17 = 0;
            }
            // 0x6bb4
            v21 = v11;
            if (*(char *)v21 == 4) {
                // 0x6bb4
                v18 = v29;
                v19 = v17;
                v20 = v16;
                // branch -> 0x6bf0
            } else {
                // 0x6bc1
                v25 = *(int32_t *)(v21 + 88);
                if (v25 != 0) {
                    // 0x6bc8
                    if (*(int32_t *)(v21 + 92) != 0) {
                        // 0x6bce
                        if (v25 <= 40) {
                            // 0x6bd3
                            *(int32_t *)(v13 + 124) = v25;
                            v22 = v11;
                            v26 = *(int32_t *)(v22 + 88);
                            v27 = *(int32_t *)(v22 + 92);
                            g7 = v27;
                            v23 = v13 + 128;
                            g5 = v23;
                            memcpy((char *)v23, (char *)v27, v26 / 4);
                            v18 = v26 % 4;
                            v19 = g7;
                            v20 = g5;
                            // branch -> 0x6bf0
                        } else {
                            v18 = v25;
                            v19 = v17;
                            v20 = v16;
                        }
                    } else {
                        v18 = v25;
                        v19 = v17;
                        v20 = v16;
                    }
                } else {
                    v18 = 0;
                    v19 = v17;
                    v20 = v16;
                }
            }
            // 0x6bf0
            memcpy((char *)v20, (char *)v19, v18);
            v24 = v11;
            v28 = *(int32_t *)(v24 + 48);
            _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g2 - 32), (int16_t *)(v24 + 32), v28);
            _qm_KerbUpdateCurrentTime__YGXT_LARGE_INTEGER___Z();
            function_6c1d();
            return;
        }
        v16 = v15;
        v17 = v15;
    }
    // 0x6bb4
    v21 = v11;
    if (*(char *)v21 == 4) {
        // 0x6bb4
        // branch -> 0x6bf0
        // 0x6bf0
        memcpy((char *)v16, (char *)v17, v14);
        v24 = v11;
        v28 = *(int32_t *)(v24 + 48);
        _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g2 - 32), (int16_t *)(v24 + 32), v28);
        _qm_KerbUpdateCurrentTime__YGXT_LARGE_INTEGER___Z();
        function_6c1d();
        return;
    }
    // 0x6bc1
    v25 = *(int32_t *)(v21 + 88);
    if (v25 == 0) {
        // 0x6bf0
        memcpy((char *)v16, (char *)v17, 0);
        v24 = v11;
        v28 = *(int32_t *)(v24 + 48);
        _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g2 - 32), (int16_t *)(v24 + 32), v28);
        _qm_KerbUpdateCurrentTime__YGXT_LARGE_INTEGER___Z();
        function_6c1d();
        return;
    }
    // 0x6bc8
    if (*(int32_t *)(v21 + 92) == 0) {
        // 0x6bf0
        memcpy((char *)v16, (char *)v17, v25);
        v24 = v11;
        v28 = *(int32_t *)(v24 + 48);
        _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g2 - 32), (int16_t *)(v24 + 32), v28);
        _qm_KerbUpdateCurrentTime__YGXT_LARGE_INTEGER___Z();
        function_6c1d();
        return;
    }
    // 0x6bce
    if (v25 <= 40) {
        // 0x6bd3
        *(int32_t *)(v13 + 124) = v25;
        v22 = v11;
        v26 = *(int32_t *)(v22 + 88);
        v27 = *(int32_t *)(v22 + 92);
        g7 = v27;
        v23 = v13 + 128;
        g5 = v23;
        memcpy((char *)v23, (char *)v27, v26 / 4);
        v18 = v26 % 4;
        v19 = g7;
        v20 = g5;
        // branch -> 0x6bf0
    } else {
        v18 = v25;
        v19 = v17;
        v20 = v16;
    }
    // 0x6bf0
    memcpy((char *)v20, (char *)v19, v18);
    v24 = v11;
    v28 = *(int32_t *)(v24 + 48);
    _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g2 - 32), (int16_t *)(v24 + 32), v28);
    _qm_KerbUpdateCurrentTime__YGXT_LARGE_INTEGER___Z();
    function_6c1d();
}

// Address range: 0x6c1d - 0x6c25
void function_6c1d(void) {
    // 0x6c1d
    function_6c26();
}

// Address range: 0x6c26 - 0x6c7b
void function_6c26(void) {
    // 0x6c26
    function_6d4b();
}

// Address range: 0x6c7c - 0x6d4a
void function_6c7c(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g1; // 0x6c7c
    *(int32_t *)(g3 + 172) = v1;
    int32_t * v2; // 0x6cfa_0
    uint32_t v3; // 0x6d07
    char * v4;
    int32_t v5; // 0x6cfd
    int32_t v6; // 0x6d00
    if (v1 == g7) {
        // 0x6cf3
        *(int32_t *)(g2 - 4) = -0x3fffff66;
        // branch -> 0x6cfa
        // 0x6cfa
        v2 = (int32_t *)(g2 - 76);
        *v2 = *v2 - 1;
        v5 = g2;
        v6 = *(int32_t *)(v5 - 72 + 4 * *(int32_t *)(v5 - 76));
        v4 = (char *)v6;
        v3 = *(int32_t *)(v5 - 88) - v6;
        memset(v4, 0, v3 / 4);
        memset(v4, 0, v3 % 4);
        function_6d4b();
        return;
    }
    int32_t v7 = g2; // 0x6c87
    int32_t v8 = v7 - 96; // 0x6c8c
    int32_t v9 = _qm_KerbVerifyAccountCreationPreAuth__YGJPAVCScratchMemoryAllocator__PAUKERB_PA_DATA__PBUKERB_ENCRYPTION_KEY__PAUXKERB_TGT_CONTEXT___Z(v8, g5, v7 - 36, g3); // 0x6c90
    int32_t v10 = g2; // 0x6c9e
    if (v9 == g7) {
        int32_t * v11 = (int32_t *)(v10 - 76); // 0x6c9e_0
        *v11 = *v11 - 1;
        int32_t v12 = g2; // 0x6ca1
        int32_t v13 = *(int32_t *)(v12 - 72 + 4 * *(int32_t *)(v12 - 76)); // 0x6ca4
        char * v14 = (char *)v13;
        int32_t * v15 = (int32_t *)(v12 - 88); // 0x6ca8_0
        uint32_t v16 = *v15 - v13; // 0x6cab
        *v15 = v13;
        memset(v14, 0, v16 / 4);
        memset(v14, 0, v16 % 4);
        int32_t v17 = g2; // 0x6cc0
        int32_t v18 = *(int32_t *)(v17 - 88); // 0x6cc3
        *(int32_t *)(v17 - 72 + 4 * *(int32_t *)(v17 - 76)) = v18;
        int32_t * v19 = (int32_t *)(g2 - 76); // 0x6cca_0
        *v19 = *v19 + 1;
        int32_t v20 = g2; // 0x6ccd
        int32_t v21 = v20 - 96; // bp-20
        int32_t * v22 = (int32_t *)(g3 + 356); // 0x6ce5_0
        *v22 = g7;
        *(int32_t *)(g2 - 24) = g7;
        int32_t v23 = *(int32_t *)(v20 - 8) + 28; // 0x6cea
        int32_t v24 = v20 - 24; // 0x6cea
        if (_qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(v21, v23, 29, v22, (int32_t *)v24, 0, a1, a2) == 0) {
            int32_t * v25 = (int32_t *)(g2 - 76); // 0x6d25_0
            *v25 = *v25 - 1;
            int32_t v26 = *(int32_t *)(g2 - 72 + 4 * *(int32_t *)(g2 - 76)); // 0x6d2b
            char * v27 = (char *)v26;
            uint32_t v28 = *(int32_t *)(g2 - 88) - v26; // 0x6d32
            memset(v27, 0, v28 / 4);
            memset(v27, 0, v28 % 4);
            *(int32_t *)(g2 - 4) = -0x3fffff93;
            return;
        }
        // 0x6cf3
        *(int32_t *)(g2 - 4) = -0x3fffff66;
        // branch -> 0x6cfa
    } else {
        // 0x6c99
        *(int32_t *)(v10 - 4) = v9;
        // branch -> 0x6cfa
    }
    // 0x6cfa
    v2 = (int32_t *)(g2 - 76);
    *v2 = *v2 - 1;
    v5 = g2;
    v6 = *(int32_t *)(v5 - 72 + 4 * *(int32_t *)(v5 - 76));
    v4 = (char *)v6;
    v3 = *(int32_t *)(v5 - 88) - v6;
    memset(v4, 0, v3 / 4);
    memset(v4, 0, v3 % 4);
    function_6d4b();
}

// Address range: 0x6d4b - 0x6d57
int32_t function_6d4b(void) {
    // 0x6d4b
    return *(int32_t *)(g2 - 4);
}

// Address range: 0x6d58 - 0x6e3f
void function_6d58(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(g2 - 24); // 0x6d58
    char * v2 = (char *)v1;
    g7 = v1;
    uint32_t v3 = g4; // 0x6d5b
    char * v4 = (char *)(g3 + 360);
    memcpy(v4, v2, v3 / 4);
    memcpy(v4, v2, v3 % 4);
    int32_t * v5 = (int32_t *)(g2 - 76); // 0x6d6f_0
    *v5 = *v5 - 1;
    int32_t v6 = g2; // 0x6d72
    int32_t v7 = *(int32_t *)(v6 - 72 + 4 * *(int32_t *)(v6 - 76)); // 0x6d75
    char * v8 = (char *)v7;
    g5 = v7;
    int32_t * v9 = (int32_t *)(v6 - 88); // 0x6d79_0
    uint32_t v10 = *v9 - v7; // 0x6d7c
    *v9 = v7;
    memset(v8, 0, v10 / 4);
    memset(v8, 0, v10 % 4);
    int32_t v11 = g2; // 0x6d91
    int32_t v12 = *(int32_t *)(v11 - 8) + 72; // 0x6d9e
    int32_t v13 = v11 - 96; // 0x6da2
    _qm_KerbUnpackKdcReplyBody__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__PAUKERB_ENCRYPTION_KEY__KPAPAUKERB_ENCRYPTED_KDC_REPLY___Z(v13, v12, v11 - 36, 45, (int32_t *)(v11 - 12));
    int32_t v14 = g3; // 0x6daf
    int32_t * v15 = (int32_t *)(v14 + 56); // 0x6daf_0
    int32_t v16 = *(int32_t *)(g2 - 12); // 0x6db2
    g6 = 0;
    if (*v15 != 0) {
        int32_t v17 = v14 + 60; // 0x6dbe
        g4 = v17;
        int32_t v18 = 0; // 0x6dc5
        // branch -> 0x6dc1
        while (true) {
            // 0x6dc1
            if (*(int32_t *)v17 != *(int32_t *)(v16 + 20)) {
                int32_t v19 = v18 + 1; // 0x6dc5
                g6 = v19;
                int32_t v20 = v17 + 4; // 0x6dc6
                g4 = v20;
                if (v19 >= *v15) {
                    // break -> 0x6dce
                    break;
                }
                v18 = v19;
                v17 = v20;
                // continue -> 0x6dc1
                continue;
            }
            // 0x6dce
            // branch -> 0x6dce
        }
        // 0x6dce
        // branch -> 0x6dce
    }
    int32_t v21 = *(int32_t *)(v16 + 12); // 0x6dea
    *(int32_t *)(v14 + 320) = *(int32_t *)v21;
    *(int32_t *)(v14 + 324) = *(int32_t *)(v21 + 4);
    int32_t v22 = g3 + 176; // bp-44
    *(int32_t *)(v14 + 328) = *(int32_t *)(v21 + 8);
    int32_t v23 = *(int32_t *)(g2 - 8) + 20; // 0x6e02
    g1 = v23;
    *(int32_t *)(v14 + 332) = *(int32_t *)(v21 + 12);
    g7 = v21 + 16;
    g5 = v14 + 336;
    _qm_KerbPrincipalNameToMultiString__YGJPAUKERB_PRINCIPAL_NAME__KPAD_Z((int32_t *)v23, 64, v22, v13, v12);
    int32_t v24 = *(int32_t *)(*(int32_t *)(g2 - 8) + 16); // 0x6e17
    g7 = v24 + 1;
    int32_t v25 = (int32_t)*(char *)v24 | g4 & -256; // 0x6e1f
    // branch -> 0x6e1f
    while (v25 != 0) {
        // 0x6e1f
        v24++;
        v25 = (int32_t)*(char *)v24 | v25 & -256;
        // continue -> 0x6e1f
    }
    // 0x6e26
    function_6e40();
}

// Address range: 0x6e40 - 0x6e68
int32_t function_6e40(void) {
    int32_t v1 = *(int32_t *)(g2 - 12); // 0x6e40
    _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g3 + 48), (int16_t *)(v1 + 76), 0);
    int32_t v2 = *(int32_t *)(g2 - 12); // 0x6e52
    _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g3 + 40), (int16_t *)(v2 + 62), 0);
    return function_6d4b();
}

// Address range: 0x703f - 0x7061
int32_t _qm_XkerbVerifyTgsReply_CXo__IAEJPAUXKERB_TGT_CONTEXT__PAEKPAUXKERB_SERVICE_CONTEXT___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g7; // 0x7046
    g3 = 0;
    g7 = g4;
    function_7062(g5, v2);
    return 3000;
}

// Address range: 0x7062 - 0x7140
void function_7062(int32_t a1, int32_t a2) {
    int32_t v1;
    *(int32_t *)(g2 - 88) = (int32_t)&v1;
    *(int32_t *)(g2 - 92) = g5;
    *(int32_t *)(g2 - 76) = g3;
    *(int32_t *)(g2 - 84) = g5;
    *(int32_t *)(g2 - 72) = g3;
    int32_t v2;
    memset((char *)g5, (int32_t)&v2, 750);
    int32_t v3 = g2; // 0x7082
    int32_t v4 = *(int32_t *)(v3 + 16); // bp-12
    int32_t v5 = *(int32_t *)(v3 + 12); // 0x708e
    *(int32_t *)(v3 - 80) = g3;
    int32_t v6 = v3 - 92; // bp-20
    *(int32_t *)(g2 - 36) = g7;
    _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v6, v5, v4, 44, (int32_t *)(v3 - 8), v2);
    int32_t v7 = g2; // 0x70a5
    int32_t v8 = *(int32_t *)(v7 + 16); // bp-32
    int32_t v9 = *(int32_t *)(v7 + 12); // 0x70b1
    int32_t * v10 = (int32_t *)(v7 + 8); // 0x70b4_0
    *v10 = g3;
    _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v7 - 92, v9, v8, 5, v10, v6);
    int32_t v11 = g2; // 0x70c5
    int32_t v12 = *(int32_t *)(v11 + 8); // 0x70c5
    *(int32_t *)(v11 - 4) = *(int32_t *)(v12 + 52) | -0x50010000;
    int32_t v13 = g2; // 0x70d7
    int32_t v14 = *(int32_t *)(v13 + 20); // 0x70d7
    int32_t v15 = *(int32_t *)(v14 + 116); // 0x70da
    g5 = v15;
    *(int32_t *)(v13 + 16) = v15;
    int32_t v16; // 0x711e
    if (*(char *)v12 == 8 || *(int32_t *)(v12 + 80) != 4) {
        // 0x710b
        v16 = *(int32_t *)(v12 + 48);
        _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g2 - 28), (int16_t *)(v12 + 32), v16);
        _qm_KerbUpdateCurrentTime__YGXT_LARGE_INTEGER___Z();
        function_7141(*(int32_t *)(g2 - 28));
        return;
    }
    int32_t v17 = *(int32_t *)(v12 + 84); // 0x70ea
    g7 = v17;
    if (v17 != g3) {
        // 0x70f1
        if (g5 > g3) {
            int32_t v18 = v14 + 120; // 0x70f7
            g5 = v18;
            int32_t v19 = 0; // 0x7100
            // branch -> 0x70fa
            while (true) {
                // 0x70fa
                if (*(int32_t *)v18 != *(int32_t *)v17) {
                    int32_t v20 = v19 + 1; // 0x7100
                    int32_t v21 = v18 + 4; // 0x7101
                    g5 = v21;
                    if (v20 >= *(int32_t *)(v14 + 116)) {
                        // break -> 0x7109
                        break;
                    }
                    v19 = v20;
                    v18 = v21;
                    // continue -> 0x70fa
                    continue;
                }
                // 0x7109
                // branch -> 0x710b
                // 0x710b
                v16 = *(int32_t *)(v12 + 48);
                _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g2 - 28), (int16_t *)(v12 + 32), v16);
                _qm_KerbUpdateCurrentTime__YGXT_LARGE_INTEGER___Z();
                function_7141(*(int32_t *)(g2 - 28));
                return;
            }
            // 0x7109
            // branch -> 0x710b
        }
    }
    // 0x710b
    v16 = *(int32_t *)(v12 + 48);
    _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g2 - 28), (int16_t *)(v12 + 32), v16);
    _qm_KerbUpdateCurrentTime__YGXT_LARGE_INTEGER___Z();
    function_7141(*(int32_t *)(g2 - 28));
}

// Address range: 0x7141 - 0x7148
void function_7141(int32_t a1) {
    // 0x7141
    function_7149();
}

// Address range: 0x7149 - 0x718a
void function_7149(void) {
    // 0x7149
    function_739d();
}

// Address range: 0x718b - 0x739c
void function_718b(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g2; // 0x718b
    int32_t v2 = *(int32_t *)(v1 + 20); // 0x718b
    int32_t v3;
    int32_t v4 = &v3; // 0x718e_0
    g5 = v4;
    int32_t v5 = v1 - 32; // 0x7192
    int32_t v6 = g7; // 0x7196
    int32_t v7 = v1 - 92; // 0x7197
    int32_t v8 = _qm_KerbVerifyServiceAddressPreAuth__YGJPAVCScratchMemoryAllocator__PAUKERB_PA_DATA__PBUKERB_ENCRYPTION_KEY__PAUXKERB_SERVICE_CONTEXT__PAU_XKERB_PA_XBOX_SERVICE_ADDRESS___Z(v7, v6, v5, v2, v4); // 0x719b
    if (v8 != 0) {
        // 0x71a4
        *(int32_t *)(g2 - 4) = v8;
        function_739d();
        return;
    }
    // 0x71ac
    *(int32_t *)(g3 + 216) = v3;
    int32_t * v9; // 0x731a_0
    int32_t * v10; // 0x7345_0
    int32_t * v11; // 0x7377_0
    int32_t v12; // 0x733c
    int32_t v13; // bp-24
    uint32_t v14; // 0x7352
    uint32_t v15; // 0x7384
    char * v16;
    char * v17;
    int32_t v18; // 0x7310
    int32_t v19; // 0x7321
    int32_t v20; // 0x7328
    int32_t v21; // 0x7348
    int32_t v22; // 0x737a
    int32_t v23; // 0x7313
    int32_t v24; // 0x7325
    int32_t v25; // 0x734b
    int32_t v26; // 0x737d
    if (v3 < 0) {
        // 0x71ac
        // branch -> 0x7310
    } else {
        // 0x71bd
        int32_t v27;
        *(int32_t *)(g3 + 440) = v27;
        int32_t v28 = g3; // 0x71c8
        uint32_t v29 = *(int32_t *)(v28 + 48); // 0x71c8
        int32_t v30 = 12; // 0x71cb
        int32_t v31; // 0x72fe
        int32_t v32; // 0x7301
        int32_t v33; // 0x72f0_0
        int32_t v34; // eax
        int32_t v35; // ecx
        int32_t v36;
        int32_t v37;
        int32_t v38; // 0x72ea
        int32_t v39; // 0x7304
        if (v29 > v30) {
            // 0x7238
            *(int32_t *)(g2 + 12) = v28 + 52;
            *(int32_t *)(g2 + 16) = g3 + 448;
            int32_t v40 = g3 + 512; // esi
            *(int32_t *)(g2 + 20) = v30;
            // branch -> 0x7250
          lab_0x7250:;
            int32_t v41; // 0x72a1
            int32_t v42; // 0x72a1
            while (true) {
                int32_t v43 = g2; // 0x7250
                int32_t v44 = g6 & -256 | (int32_t)*(char *)*(int32_t *)(v43 + 12); // 0x7253
                g6 = v44;
                int32_t * v45; // 0x727f_0
                int32_t * v46; // 0x7286_0
                int32_t * v47; // 0x7289_0
                int32_t v48; // 0x7289
                if (v44 != 0) {
                    int32_t v49 = 0; // 0x726d
                    int32_t v50 = &v37; // 0x7263
                    // branch -> 0x725e
                    while (true) {
                        // 0x725e
                        if (v44 == (int32_t)*(char *)v50) {
                            int32_t v51 = g5 + 8 * v49; // 0x726d
                            *(int32_t *)v40 = *(int32_t *)(v51 + 84);
                            *(int16_t *)*(int32_t *)(g2 + 16) = *(int16_t *)(v51 + 82);
                            // branch -> 0x727f
                        } else {
                            int32_t v52 = v49 + 1; // 0x7262
                            if (v52 >= 12) {
                                // break -> 0x727f
                                break;
                            }
                            v49 = v52;
                            v50 += 8;
                            // continue -> 0x725e
                            continue;
                        }
                        // 0x727f
                        v45 = (int32_t *)(g2 + 16);
                        *v45 = *v45 + 2;
                        v40 += 4;
                        v46 = (int32_t *)(g2 + 12);
                        *v46 = *v46 + 1;
                        v47 = (int32_t *)(g2 + 20);
                        v48 = *v47 - 1;
                        *v47 = v48;
                        if (v48 == 0) {
                            // break (via goto) -> 0x728e
                            goto lab_0x728e;
                        }
                        // continue (via goto) -> 0x7250
                        goto lab_0x7250;
                    }
                    // 0x728e
                    *(int32_t *)(g2 + 16) = g3 + 472;
                    v35 = g3 + 84;
                    *(int32_t *)(g2 + 12) = 4;
                    // branch -> 0x72a1
                    while (true) {
                        // 0x72a1
                        v41 = v35;
                        v42 = *(int32_t *)v41;
                        int32_t * v53; // 0x72dc_0
                        int32_t * v54; // 0x72e3_0
                        int32_t v55; // 0x72e3
                        if (v42 != 0) {
                          lab_0x72a7:
                            // 0x72a7
                            v34 = 0;
                            int32_t v56 = 0; // 0x72be
                            int32_t v57;
                            int32_t v58 = &v57; // 0x72b4
                            // branch -> 0x72af
                            while (true) {
                                // 0x72af
                                if (v42 == *(int32_t *)v58) {
                                    int32_t v59 = *(int32_t *)(g5 + 4 * (v56 + 45 + 2 * v56)); // 0x72c2
                                    *(int32_t *)(v41 + 476) = v59;
                                    int16_t v60 = *(int16_t *)(g5 + 184 + 12 * v34); // 0x72d1
                                    *(int16_t *)*(int32_t *)(g2 + 16) = v60;
                                    // branch -> 0x72dc
                                } else {
                                    int32_t v61 = v56 + 1; // 0x72b3
                                    v34 = v61;
                                    if (v61 >= 4) {
                                        // break -> 0x72dc
                                        break;
                                    }
                                    v56 = v61;
                                    v58 += 12;
                                    // continue -> 0x72af
                                    continue;
                                }
                                // 0x72dc
                                v53 = (int32_t *)(g2 + 16);
                                *v53 = *v53 + 2;
                                v35 += 4;
                                v54 = (int32_t *)(g2 + 12);
                                v55 = *v54 - 1;
                                *v54 = v55;
                                if (v55 == 0) {
                                    // break (via goto) -> 0x72e8
                                    goto lab_0x72e8;
                                }
                                // continue (via goto) -> 0x72a1
                                goto lab_0x72a1;
                            }
                            // 0x72e8
                            // branch -> 0x72e8
                            // 0x72e8
                            v38 = g3 + 480;
                            v35 = v38;
                            v33 = &a1;
                            v34 = v33;
                            *(int32_t *)(v38 + 16) = *(int32_t *)(v33 + 16);
                            *(int32_t *)v35 = *(int32_t *)v34;
                            v31 = v34 + 4;
                            v34 = v31;
                            v32 = v35 + 4;
                            v35 = v32;
                            v39 = 3;
                            // branch -> 0x72f4
                            while (v39 != 0) {
                                // 0x72f4
                                *(int32_t *)(v32 + 16) = *(int32_t *)(v31 + 16);
                                *(int32_t *)v35 = *(int32_t *)v34;
                                v31 = v34 + 4;
                                v34 = v31;
                                v32 = v35 + 4;
                                v35 = v32;
                                v39--;
                                // continue -> 0x72f4
                            }
                            // 0x7307
                            *(int32_t *)(g3 + 444) = v36;
                            // branch -> 0x7310
                            // 0x7310
                            v18 = g2;
                            v23 = *(int32_t *)(v18 - 84);
                            *(int32_t *)(v18 - 68 + 4 * *(int32_t *)(v18 - 72)) = v23;
                            v9 = (int32_t *)(g2 - 72);
                            *v9 = *v9 + 1;
                            *(int32_t *)(g2 - 16) = 0;
                            v19 = g2;
                            v13 = v19 - 16;
                            v24 = *(int32_t *)(v19 - 8);
                            v20 = g3 + 732;
                            *(int32_t *)v20 = 0;
                            v12 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(g2 - 92, v24 + 28, 29, (int32_t *)v20, (int32_t *)v13, v7, v6, v5);
                            if (v12 == 0) {
                                // 0x736d
                                v11 = (int32_t *)(g2 - 72);
                                *v11 = *v11 - 1;
                                v22 = g2;
                                v26 = *(int32_t *)(v22 - 68 + 4 * *(int32_t *)(v22 - 72));
                                v17 = (char *)v26;
                                v15 = *(int32_t *)(v22 - 84) - v26;
                                memset(v17, 0, v15 / 4);
                                memset(v17, 0, v15 % 4);
                                *(int32_t *)(g2 - 4) = -0x3fffff93;
                                return;
                            }
                            // 0x7345
                            v10 = (int32_t *)(g2 - 72);
                            *v10 = *v10 - 1;
                            v21 = g2;
                            v25 = *(int32_t *)(v21 - 68 + 4 * *(int32_t *)(v21 - 72));
                            v16 = (char *)v25;
                            v14 = *(int32_t *)(v21 - 84) - v25;
                            memset(v16, 0, v14 / 4);
                            *(int32_t *)(g2 - 4) = -0x3fffff66;
                            memset(v16, 0, v14 % 4);
                            function_739d();
                            return;
                        }
                      lab_0x72dc:
                        // 0x72dc
                        v53 = (int32_t *)(g2 + 16);
                        *v53 = *v53 + 2;
                        v35 += 4;
                        v54 = (int32_t *)(g2 + 12);
                        v55 = *v54 - 1;
                        *v54 = v55;
                        if (v55 == 0) {
                            // break -> 0x72e8
                            break;
                        }
                        // continue -> 0x72a1
                    }
                  lab_0x72e8:
                    // 0x72e8
                    // branch -> 0x72e8
                    // 0x72e8
                    v38 = g3 + 480;
                    v35 = v38;
                    v33 = &a1;
                    v34 = v33;
                    *(int32_t *)(v38 + 16) = *(int32_t *)(v33 + 16);
                    *(int32_t *)v35 = *(int32_t *)v34;
                    v31 = v34 + 4;
                    v34 = v31;
                    v32 = v35 + 4;
                    v35 = v32;
                    v39 = 3;
                    // branch -> 0x72f4
                    while (v39 != 0) {
                        // 0x72f4
                        *(int32_t *)(v32 + 16) = *(int32_t *)(v31 + 16);
                        *(int32_t *)v35 = *(int32_t *)v34;
                        v31 = v34 + 4;
                        v34 = v31;
                        v32 = v35 + 4;
                        v35 = v32;
                        v39--;
                        // continue -> 0x72f4
                    }
                    // 0x7307
                    *(int32_t *)(g3 + 444) = v36;
                    // branch -> 0x7310
                    // 0x7310
                    v18 = g2;
                    v23 = *(int32_t *)(v18 - 84);
                    *(int32_t *)(v18 - 68 + 4 * *(int32_t *)(v18 - 72)) = v23;
                    v9 = (int32_t *)(g2 - 72);
                    *v9 = *v9 + 1;
                    *(int32_t *)(g2 - 16) = 0;
                    v19 = g2;
                    v13 = v19 - 16;
                    v24 = *(int32_t *)(v19 - 8);
                    v20 = g3 + 732;
                    *(int32_t *)v20 = 0;
                    v12 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(g2 - 92, v24 + 28, 29, (int32_t *)v20, (int32_t *)v13, v7, v6, v5);
                    if (v12 == 0) {
                        // 0x736d
                        v11 = (int32_t *)(g2 - 72);
                        *v11 = *v11 - 1;
                        v22 = g2;
                        v26 = *(int32_t *)(v22 - 68 + 4 * *(int32_t *)(v22 - 72));
                        v17 = (char *)v26;
                        v15 = *(int32_t *)(v22 - 84) - v26;
                        memset(v17, 0, v15 / 4);
                        memset(v17, 0, v15 % 4);
                        *(int32_t *)(g2 - 4) = -0x3fffff93;
                        return;
                    }
                    // 0x7345
                    v10 = (int32_t *)(g2 - 72);
                    *v10 = *v10 - 1;
                    v21 = g2;
                    v25 = *(int32_t *)(v21 - 68 + 4 * *(int32_t *)(v21 - 72));
                    v16 = (char *)v25;
                    v14 = *(int32_t *)(v21 - 84) - v25;
                    memset(v16, 0, v14 / 4);
                    *(int32_t *)(g2 - 4) = -0x3fffff66;
                    memset(v16, 0, v14 % 4);
                    function_739d();
                    return;
                }
                // 0x727f
                v45 = (int32_t *)(v43 + 16);
                *v45 = *v45 + 2;
                v40 += 4;
                v46 = (int32_t *)(g2 + 12);
                *v46 = *v46 + 1;
                v47 = (int32_t *)(g2 + 20);
                v48 = *v47 - 1;
                *v47 = v48;
                if (v48 == 0) {
                    // break -> 0x728e
                    break;
                }
                // continue -> 0x7250
            }
          lab_0x728e:
            // 0x728e
            *(int32_t *)(g2 + 16) = g3 + 472;
            v35 = g3 + 84;
            *(int32_t *)(g2 + 12) = 4;
            // branch -> 0x72a1
          lab_0x72a1:
            while (true) {
                // 0x72a1
                v41 = v35;
                v42 = *(int32_t *)v41;
                if (v42 == 0) {
                    goto lab_0x72dc;
                }
                goto lab_0x72a7;
            }
        } else {
            // 0x71d0
            *(int32_t *)(g2 + 12) = 0;
            if (v29 != 0) {
                // 0x71dc
                *(int32_t *)(g2 + 16) = g3 + 560;
                int32_t v62 = g3; // 0x71e5
                int32_t v63 = v62 + 512; // 0x71e5
                v35 = v63;
                // branch -> 0x71eb
              lab_0x71eb:
                while (true) {
                    // 0x71eb
                    v34 = 0;
                    int32_t * v64 = (int32_t *)(v62 + 48); // 0x71ed_0
                    int32_t v65; // 0x722b
                    int32_t * v66; // 0x7221_0
                    int32_t * v67; // 0x7227_0
                    int32_t v68; // 0x7224
                    int32_t v69; // 0x722e
                    if (*v64 != 0) {
                        int32_t v70 = 0; // 0x720a
                        int32_t v71 = &v37; // 0x7200
                        // branch -> 0x71fb
                        while (true) {
                            // 0x71fb
                            if (*(int32_t *)(v63 - 460) == *(int32_t *)v71) {
                                int32_t v72 = *(int32_t *)(g5 + 4 * (v70 + 21 + 2 * v70)); // 0x720e
                                *(int32_t *)v63 = v72;
                                int16_t v73 = *(int16_t *)(g5 + 88 + 12 * v34); // 0x7219
                                *(int16_t *)*(int32_t *)(g2 + 16) = v73;
                                // branch -> 0x7221
                            } else {
                                int32_t v74 = v70 + 1; // 0x71ff
                                v34 = v74;
                                if (v74 >= *v64) {
                                    // break -> 0x7221
                                    break;
                                }
                                v70 = v74;
                                v71 += 12;
                                // continue -> 0x71fb
                                continue;
                            }
                            // 0x7221
                            v66 = (int32_t *)(g2 + 12);
                            *v66 = *v66 + 1;
                            v68 = g2;
                            v67 = (int32_t *)(v68 + 16);
                            *v67 = *v67 + 2;
                            v65 = v35 + 4;
                            v35 = v65;
                            v69 = g3;
                            if (*(int32_t *)(v68 + 12) >= *(int32_t *)(v69 + 48)) {
                                // break (via goto) -> 0x72e8
                                goto lab_0x72e8_2;
                            }
                            v63 = v65;
                            v62 = v69;
                            // continue (via goto) -> 0x71eb
                            goto lab_0x71eb;
                        }
                        // 0x72e8
                        // branch -> 0x72e8
                        // 0x72e8
                        v38 = g3 + 480;
                        v35 = v38;
                        v33 = &a1;
                        v34 = v33;
                        *(int32_t *)(v38 + 16) = *(int32_t *)(v33 + 16);
                        *(int32_t *)v35 = *(int32_t *)v34;
                        v31 = v34 + 4;
                        v34 = v31;
                        v32 = v35 + 4;
                        v35 = v32;
                        v39 = 3;
                        // branch -> 0x72f4
                        while (v39 != 0) {
                            // 0x72f4
                            *(int32_t *)(v32 + 16) = *(int32_t *)(v31 + 16);
                            *(int32_t *)v35 = *(int32_t *)v34;
                            v31 = v34 + 4;
                            v34 = v31;
                            v32 = v35 + 4;
                            v35 = v32;
                            v39--;
                            // continue -> 0x72f4
                        }
                        // 0x7307
                        *(int32_t *)(g3 + 444) = v36;
                        // branch -> 0x7310
                        // 0x7310
                        v18 = g2;
                        v23 = *(int32_t *)(v18 - 84);
                        *(int32_t *)(v18 - 68 + 4 * *(int32_t *)(v18 - 72)) = v23;
                        v9 = (int32_t *)(g2 - 72);
                        *v9 = *v9 + 1;
                        *(int32_t *)(g2 - 16) = 0;
                        v19 = g2;
                        v13 = v19 - 16;
                        v24 = *(int32_t *)(v19 - 8);
                        v20 = g3 + 732;
                        *(int32_t *)v20 = 0;
                        v12 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(g2 - 92, v24 + 28, 29, (int32_t *)v20, (int32_t *)v13, v7, v6, v5);
                        if (v12 == 0) {
                            // 0x736d
                            v11 = (int32_t *)(g2 - 72);
                            *v11 = *v11 - 1;
                            v22 = g2;
                            v26 = *(int32_t *)(v22 - 68 + 4 * *(int32_t *)(v22 - 72));
                            v17 = (char *)v26;
                            v15 = *(int32_t *)(v22 - 84) - v26;
                            memset(v17, 0, v15 / 4);
                            memset(v17, 0, v15 % 4);
                            *(int32_t *)(g2 - 4) = -0x3fffff93;
                            return;
                        }
                        // 0x7345
                        v10 = (int32_t *)(g2 - 72);
                        *v10 = *v10 - 1;
                        v21 = g2;
                        v25 = *(int32_t *)(v21 - 68 + 4 * *(int32_t *)(v21 - 72));
                        v16 = (char *)v25;
                        v14 = *(int32_t *)(v21 - 84) - v25;
                        memset(v16, 0, v14 / 4);
                        *(int32_t *)(g2 - 4) = -0x3fffff66;
                        memset(v16, 0, v14 % 4);
                        function_739d();
                        return;
                    }
                    // 0x7221
                    v66 = (int32_t *)(g2 + 12);
                    *v66 = *v66 + 1;
                    v68 = g2;
                    v67 = (int32_t *)(v68 + 16);
                    *v67 = *v67 + 2;
                    v65 = v35 + 4;
                    v35 = v65;
                    v69 = g3;
                    if (*(int32_t *)(v68 + 12) >= *(int32_t *)(v69 + 48)) {
                        // break -> 0x72e8
                        break;
                    }
                    v63 = v65;
                    v62 = v69;
                    // continue -> 0x71eb
                }
              lab_0x72e8_2:;
                // 0x72e8
                // branch -> 0x72e8
            }
        }
        // 0x72e8
        v38 = g3 + 480;
        v35 = v38;
        v33 = &a1;
        v34 = v33;
        *(int32_t *)(v38 + 16) = *(int32_t *)(v33 + 16);
        *(int32_t *)v35 = *(int32_t *)v34;
        v31 = v34 + 4;
        v34 = v31;
        v32 = v35 + 4;
        v35 = v32;
        v39 = 3;
        // branch -> 0x72f4
        while (v39 != 0) {
            // 0x72f4
            *(int32_t *)(v32 + 16) = *(int32_t *)(v31 + 16);
            *(int32_t *)v35 = *(int32_t *)v34;
            v31 = v34 + 4;
            v34 = v31;
            v32 = v35 + 4;
            v35 = v32;
            v39--;
            // continue -> 0x72f4
        }
        // 0x7307
        *(int32_t *)(g3 + 444) = v36;
        // branch -> 0x7310
    }
    // 0x7310
    v18 = g2;
    v23 = *(int32_t *)(v18 - 84);
    *(int32_t *)(v18 - 68 + 4 * *(int32_t *)(v18 - 72)) = v23;
    v9 = (int32_t *)(g2 - 72);
    *v9 = *v9 + 1;
    *(int32_t *)(g2 - 16) = 0;
    v19 = g2;
    v13 = v19 - 16;
    v24 = *(int32_t *)(v19 - 8);
    v20 = g3 + 732;
    *(int32_t *)v20 = 0;
    v12 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(g2 - 92, v24 + 28, 29, (int32_t *)v20, (int32_t *)v13, v7, v6, v5);
    if (v12 == 0) {
        // 0x736d
        v11 = (int32_t *)(g2 - 72);
        *v11 = *v11 - 1;
        v22 = g2;
        v26 = *(int32_t *)(v22 - 68 + 4 * *(int32_t *)(v22 - 72));
        v17 = (char *)v26;
        v15 = *(int32_t *)(v22 - 84) - v26;
        memset(v17, 0, v15 / 4);
        memset(v17, 0, v15 % 4);
        *(int32_t *)(g2 - 4) = -0x3fffff93;
        return;
    }
    // 0x7345
    v10 = (int32_t *)(g2 - 72);
    *v10 = *v10 - 1;
    v21 = g2;
    v25 = *(int32_t *)(v21 - 68 + 4 * *(int32_t *)(v21 - 72));
    v16 = (char *)v25;
    v14 = *(int32_t *)(v21 - 84) - v25;
    memset(v16, 0, v14 / 4);
    *(int32_t *)(g2 - 4) = -0x3fffff66;
    memset(v16, 0, v14 % 4);
    function_739d();
}

// Address range: 0x739d - 0x73a9
int32_t function_739d(void) {
    // 0x739d
    return *(int32_t *)(g2 - 4);
}

// Address range: 0x73aa - 0x7491
void function_73aa(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(g2 - 16); // 0x73aa
    char * v2 = (char *)v1;
    g7 = v1;
    uint32_t v3 = g4; // 0x73ad
    char * v4 = (char *)(g3 + 736);
    memcpy(v4, v2, v3 / 4);
    memcpy(v4, v2, v3 % 4);
    int32_t * v5 = (int32_t *)(g2 - 72); // 0x73c1_0
    *v5 = *v5 - 1;
    int32_t v6 = g2; // 0x73c4
    int32_t v7 = *(int32_t *)(v6 - 68 + 4 * *(int32_t *)(v6 - 72)); // 0x73c7
    char * v8 = (char *)v7;
    g5 = v7;
    int32_t * v9 = (int32_t *)(v6 - 84); // 0x73cb_0
    uint32_t v10 = *v9 - v7; // 0x73ce
    *v9 = v7;
    memset(v8, 0, v10 / 4);
    memset(v8, 0, v10 % 4);
    int32_t v11 = g2; // 0x73e3
    int32_t v12 = *(int32_t *)(v11 - 8) + 72; // 0x73f0
    int32_t v13 = v11 - 92; // 0x73f4
    _qm_KerbUnpackKdcReplyBody__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__PAUKERB_ENCRYPTION_KEY__KPAPAUKERB_ENCRYPTED_KDC_REPLY___Z(v13, v12, v11 - 32, 46, (int32_t *)(v11 - 12));
    int32_t v14 = g3; // 0x7401
    int32_t * v15 = (int32_t *)(v14 + 116); // 0x7401_0
    int32_t v16 = *(int32_t *)(g2 - 12); // 0x7404
    g6 = 0;
    if (*v15 != 0) {
        int32_t v17 = v14 + 120; // 0x7410
        g4 = v17;
        int32_t v18 = 0; // 0x7417
        // branch -> 0x7413
        while (true) {
            // 0x7413
            if (*(int32_t *)v17 != *(int32_t *)(v16 + 20)) {
                int32_t v19 = v18 + 1; // 0x7417
                g6 = v19;
                int32_t v20 = v17 + 4; // 0x7418
                g4 = v20;
                if (v19 >= *v15) {
                    // break -> 0x7420
                    break;
                }
                v18 = v19;
                v17 = v20;
                // continue -> 0x7413
                continue;
            }
            // 0x7420
            // branch -> 0x7420
        }
        // 0x7420
        // branch -> 0x7420
    }
    int32_t v21 = *(int32_t *)(v16 + 12); // 0x743c
    *(int32_t *)(v14 + 696) = *(int32_t *)v21;
    *(int32_t *)(v14 + 700) = *(int32_t *)(v21 + 4);
    int32_t v22 = g3 + 584; // bp-64
    *(int32_t *)(v14 + 704) = *(int32_t *)(v21 + 8);
    int32_t v23 = *(int32_t *)(g2 - 8) + 20; // 0x7454
    g1 = v23;
    *(int32_t *)(v14 + 708) = *(int32_t *)(v21 + 12);
    g7 = v21 + 16;
    g5 = v14 + 712;
    _qm_KerbPrincipalNameToMultiString__YGJPAUKERB_PRINCIPAL_NAME__KPAD_Z((int32_t *)v23, 64, v22, v13, v12);
    int32_t v24 = *(int32_t *)(*(int32_t *)(g2 - 8) + 16); // 0x7469
    g7 = v24 + 1;
    int32_t v25 = (int32_t)*(char *)v24 | g4 & -256; // 0x7471
    // branch -> 0x7471
    while (v25 != 0) {
        // 0x7471
        v24++;
        v25 = (int32_t)*(char *)v24 | v25 & -256;
        // continue -> 0x7471
    }
    // 0x7478
    function_7492();
}

// Address range: 0x7492 - 0x74ba
int32_t function_7492(void) {
    int32_t v1 = *(int32_t *)(g2 - 12); // 0x7492
    _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g3 + 108), (int16_t *)(v1 + 76), 0);
    int32_t v2 = *(int32_t *)(g2 - 12); // 0x74a4
    _qm_KerbConvertGeneralizedTimeToLargeInt__YGXPAT_LARGE_INTEGER__PAUtagASN1generalizedtime_t__H_Z((int32_t *)(g3 + 100), (int16_t *)(v2 + 62), 0);
    return function_739d();
}

// Address range: 0x76b4 - 0x779a
int32_t _qm_KerbCreateAuthenticator__YGJPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KKPAT_LARGE_INTEGER__PAD3PBUKERB_CHECKSUM__EPAUKERB_ENCRYPTED_DATA___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t * a8, uint32_t a9, int32_t a10) {
    // 0x76b4
    int32_t v1;
    char v2 = v1; // bp-76
    int32_t v3 = (int32_t)a8; // bp+32
    int32_t v4 = &v2;
    g3 = a1;
    int32_t v5 = g7; // 0x76be
    g7 = a10;
    *(int32_t *)(a10 + 16) = 0;
    int32_t v6 = g5; // 0x76c6
    g5 = v4;
    memset(&v2, 0, 18);
    int32_t v7;
    int32_t v8 = &v7; // 0x76d7_0
    int32_t v9 = _qm_KerbMultiStringToPrincipalName__YGJPAVCScratchMemoryAllocator__PADPAUKERB_PRINCIPAL_NAME___Z(g3, a6, &v7, v6, v5); // 0x76e6
    int32_t result = v9; // 0x7798_2
    int32_t v10;
    if (v9 == 0) {
        // 0x76f3
        int32_t v11;
        int32_t v12 = &v11; // 0x76f6_0
        int32_t v13;
        int32_t v14 = &v13; // bp-112
        _qm_KerbConvertLargeIntToGeneralizedTime__YGXPAUtagASN1generalizedtime_t__PAJPAT_LARGE_INTEGER___Z((int16_t *)&v13, &v11, (int32_t *)a5);
        v2 |= 32;
        int32_t v15 = v3;
        if (v15 != 0) {
            // 0x7713
            int32_t v16;
            int32_t v17 = &v16; // 0x7716_0
            v16 = *(int32_t *)v15;
            *(int32_t *)(v17 + 4) = *(int32_t *)(v15 + 4);
            *(int32_t *)(v17 + 8) = *(int32_t *)(v15 + 8);
            v2 |= -128;
            // branch -> 0x7723
        }
        // 0x7723
        v3 = 0;
        a7 = 0;
        int32_t v18 = _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(g3, v4, 31, &v3, &a7, v14, v12, a5); // 0x773a
        if (v18 == g5) {
            int32_t v19 = v3;
            int32_t v20 = v19 + 24; // 0x7746
            *(int32_t *)(g7 + 12) = v20;
            int32_t v21 = g3; // 0x774c
            int32_t * v22 = (int32_t *)(v21 + 8); // 0x774c_0
            int32_t v23 = *v22; // 0x774c
            uint32_t v24 = (v20 + 3 & -4) + v23; // 0x7755
            *v22 = v24;
            if (v24 > *(int32_t *)(v21 + 4)) {
                // 0x7764
                *(int32_t *)(g3 + 8) = v23;
                *(int32_t *)(g7 + 16) = 0;
                // branch -> 0x776e
            } else {
                // 0x7764
                *(int32_t *)(g7 + 16) = v23;
                if (v23 != 0) {
                    int32_t v25 = g5;
                    result = v25;
                    if (v25 == 0) {
                        int32_t v26 = a9 % 256 == 0 ? 11 : 7; // 0x777e
                        result = _qm_KerbEncryptDataEx__YGJPAVCScratchMemoryAllocator__PAUKERB_ENCRYPTED_DATA__KPAEKKPBUKERB_ENCRYPTION_KEY___Z(g3, g7, v19, a7, a3, v26);
                        // branch -> 0x7794
                    }
                    // 0x7794
                    g3 = v8;
                    g2 = v10;
                    return result;
                }
            }
            // 0x776e
            result = 60;
            // branch -> 0x7794
        } else {
            result = v18;
        }
    }
    // 0x7794
    g3 = v8;
    g2 = v10;
    return result;
}

// Address range: 0x79f7 - 0x7ae7
int32_t _qm_KerbCreateApRequest__YGJPAVCScratchMemoryAllocator__PAD1PBUKERB_ENCRYPTION_KEY__KPAT_LARGE_INTEGER__PBUKERB_TICKET__KPBUKERB_CHECKSUM__EPAKPAPAE_Z(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, char * a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t * a12, int32_t a13, int32_t a14, int32_t a15) {
    int32_t v1 = (int32_t)a4;
    int32_t v2;
    int32_t v3 = &v2; // 0x79fa_3
    int32_t v4 = g3; // 0x7a04
    int32_t v5 = g7; // 0x7a05
    int32_t v6 = g5; // 0x7a09
    memset((char *)&v2, 0, 20);
    v2 = 5;
    _qm_KerbConvertUlongToFlagUlong__YGKK_Z(a8, v6, v5, v4, 5);
    _qm_KerbConvertUlongToFlagUlong__YGKK_Z(a8, v6, v5, v4, 5);
    g7 = (int32_t)a7;
    int32_t v7;
    g5 = &v7;
    memcpy((char *)&v7, a7, 11);
    int32_t v8 = *(int32_t *)(a1 + 8); // 0x7a52
    *(int32_t *)(a1 + 24 + 4 * *(int32_t *)(a1 + 20)) = v8;
    int32_t * v9 = (int32_t *)(a1 + 20); // 0x7a59_0
    *v9 = *v9 + 1;
    int32_t v10 = *a4; // 0x7a75
    int32_t v11;
    int32_t v12 = _qm_KerbCreateAuthenticator__YGJPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KKPAT_LARGE_INTEGER__PAD3PBUKERB_CHECKSUM__EPAUKERB_ENCRYPTED_DATA___Z(a1, v1, v10, a5, a6, a2, a3, (int32_t *)a9, a10, (int32_t)&v11); // 0x7a79
    if (v12 == 0) {
        // 0x7a85
        return _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(g3, v3, 32, (int32_t *)a11, a12, a1, v1, v10);
    }
    int32_t * v13 = (int32_t *)(g3 + 20); // 0x7aa3_0
    *v13 = *v13 - 1;
    int32_t v14 = *(int32_t *)(g3 + 24 + 4 * *(int32_t *)(g3 + 20)); // 0x7aa9
    char * v15 = (char *)v14;
    uint32_t v16 = *(int32_t *)(g3 + 8) - v14; // 0x7aad
    *(int32_t *)(g3 + 8) = v14;
    memset(v15, 0, v16 / 4);
    memset(v15, 0, v16 % 4);
    return function_7b6c();
}

// Address range: 0x7ae8 - 0x7ae9
void function_7ae8(void) {
    // 0x7ae8
    return;
}

// Address range: 0x7aea - 0x7b6b
int32_t function_7aea(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g1; // 0x7aea
    int32_t v2 = v1; // 0x7afa
    if (v1 == 0) {
        int32_t v3 = *(int32_t *)(g3 + 12); // 0x7aee
        g1 = v3;
        v2 = v3;
        // branch -> 0x7af1
    }
    char * v4 = (char *)*(int32_t *)g5;
    char * v5 = (char *)v2;
    memcpy(v5, v4, g7 / 4);
    int32_t result = *(int32_t *)(g2 + 32); // edx
    memcpy(v5, v4, g7 % 4);
    *(int32_t *)(g2 - 16) = *(int32_t *)(g2 + 52);
    *(int32_t *)(g2 - 20) = g1;
    int32_t * v6 = (int32_t *)(g3 + 20); // 0x7b16_0
    *v6 = *v6 - 1;
    int32_t v7 = *(int32_t *)(g3 + 24 + 4 * *(int32_t *)(g3 + 20)); // 0x7b1c
    char * v8 = (char *)v7;
    int32_t * v9 = (int32_t *)(g3 + 8); // 0x7b20_0
    uint32_t v10 = *v9 - v7; // 0x7b23
    *v9 = v7;
    memset(v8, 0, v10 / 4);
    int32_t v11 = *(int32_t *)(g2 - 20); // 0x7b33
    memset(v8, 0, v10 % 4);
    int32_t * v12 = (int32_t *)(g3 + 8); // 0x7b3f_0
    int32_t v13 = *v12; // 0x7b3f
    int32_t v14 = v13; // edi
    uint32_t v15 = (result + 3 & -4) + v13; // 0x7b48
    *v12 = v15;
    int32_t v16; // 0x7b5a
    if (v15 > *(int32_t *)(g3 + 4)) {
        // 0x7b52
        *(int32_t *)(g3 + 8) = v14;
        v14 = 0;
        v16 = 0;
        // branch -> 0x7b57
    } else {
        // 0x7af1
        v16 = v14;
        // branch -> 0x7b57
    }
    // 0x7b57
    *(int32_t *)*(int32_t *)(g2 - 16) = v16;
    memcpy((char *)v14, (char *)v11, result / 4);
    return result;
}

// Address range: 0x7b6c - 0x7b78
int32_t function_7b6c(void) {
    int32_t result = *(int32_t *)(g2 + 36); // 0x7b6c
    g5 = *(int32_t *)(g2 - 116);
    g2 = *(int32_t *)g2;
    return result;
}

// Address range: 0x7dc1 - 0x7ddf
int32_t _qm_XkerbBuildTgsRequest_CXo__IAEJPAUXKERB_TGT_CONTEXT__PAEPAKPAUXKERB_SERVICE_CONTEXT___Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g7; // 0x7dcd
    g3 = 0;
    g7 = g4;
    function_7de0(g5, v2);
    return 3000;
}

// Address range: 0x7de0 - 0x7e71
void function_7de0(int32_t a1, int32_t a2) {
    int32_t v1 = g2; // 0x7de0
    int32_t v2;
    int32_t v3 = &v2; // 0x7de5_0
    int32_t v4;
    *(int32_t *)(v1 + 48) = (int32_t)&v4;
    *(int32_t *)(g2 + 44) = v3;
    *(int32_t *)(g2 + 60) = g3;
    *(int32_t *)(g2 + 52) = v3;
    *(int32_t *)(g2 + 64) = g3;
    memset((char *)&v2, v3, 750);
    int32_t v5 = g2; // 0x7e05
    int32_t v6 = *(int32_t *)(v5 + 116); // 0x7e05
    *(int32_t *)(v5 + 56) = v6;
    if (v6 != g3) {
        // 0x7e0f
        *(int32_t *)(g2 + 60) = *(int32_t *)*(int32_t *)(v1 + 120);
        // branch -> 0x7e12
    }
    int32_t v7 = 0; // eax
    int32_t v8 = g2; // 0x7e14
    int32_t v9 = *(int32_t *)(v8 + 124); // 0x7e14
    g3 = v9;
    *(int32_t *)(v8 + 16) = 0;
    *(int32_t *)(v8 + 20) = v7;
    *(int32_t *)(v8 + 24) = v7;
    *(int32_t *)(v8 + 28) = v7;
    v7 = 0;
    int32_t v10 = g2; // 0x7e20
    *(int32_t *)(v10 - 12) = 0;
    *(int32_t *)(v10 - 8) = v7;
    *(int32_t *)(v10 - 4) = v7;
    *(int32_t *)(g2 + 100) = g7;
    int32_t v11 = g2; // 0x7e2c
    int32_t v12 = *(int32_t *)(v11 + 112); // 0x7e2c
    memset((char *)(v11 - 140), 0, 32);
    memcpy((char *)(v9 + 672), (char *)(v12 + 264), 6);
    g7 = &g11;
    _qm_KerbConvertLargeIntToGeneralizedTime__YGXPAUtagASN1generalizedtime_t__PAJPAT_LARGE_INTEGER___Z((int16_t *)(g2 - 78), NULL, &g11);
    _qm_KerbConvertLargeIntToGeneralizedTime__YGXPAUtagASN1generalizedtime_t__PAJPAT_LARGE_INTEGER___Z((int16_t *)(g2 - 64), (int32_t *)g5, (int32_t *)g7);
    int32_t v13 = g2 - 48; // 0x7e69
    g1 = v13;
    function_7e72(v13);
}

// Address range: 0x7e72 - 0x7ea6
void function_7e72(int32_t a1) {
    // 0x7e72
    *(int32_t *)(g2 - 44) = (int32_t)&g10;
    int32_t v1 = g3; // 0x7e84
    int32_t v2 = v1 + 52; // 0x7e84
    int32_t v3; // 0x7e91
    if (*(int32_t *)(g3 + 48) > 12) {
        int32_t v4 = (int32_t)*(char *)v2; // 0x7e84
        if ((g1 & -256 || v4) == 0) {
            // 0x7e8e
            v3 = *(int32_t *)(v1 + 84);
            // branch -> 0x7e91
        } else {
            v3 = v4;
        }
    } else {
        // 0x7e7f
        v3 = *(int32_t *)v2;
        // branch -> 0x7e91
    }
    // 0x7e91
    g7 = 16;
    int32_t v5 = g2 - 156; // 0x7e9a
    g1 = v5;
    function_7ea7(v5, 16, (int32_t)"S%u", v3);
}

// Address range: 0x7ea7 - 0x7fe6
void function_7ea7(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g2; // 0x7eb2
    int32_t v2 = v1 - 100; // 0x7ec0
    int32_t v3 = v1 + 44; // 0x7ec4
    _qm_KerbConstructPrincipalName__YGJPAVCScratchMemoryAllocator__PAUKERB_PRINCIPAL_NAME__KPAD2_Z(v3, (int32_t *)v2, 2, (int32_t)"sg", v1 - 156);
    char * v4 = (char *)(g2 - 124); // 0x7ed5_0
    *v4 = *v4 | 64;
    int32_t v5 = _qm_KerbConvertUlongToFlagUlong__YGKK_Z(0x10000, v3, v2, 2, (int32_t)"sg"); // 0x7ede
    int32_t v6 = g2; // 0x7ee3
    *(int32_t *)(v6 + 12) = v5;
    int32_t v7 = g2; // 0x7ee9
    *(int32_t *)(v7 - 116) = v7 + 12;
    *(int32_t *)(g2 - 104) = g3 + 672;
    *(int32_t *)(g2 + 4) = g7;
    int32_t v8 = g2; // 0x7efb
    int32_t v9 = *(int32_t *)(v8 + 112); // 0x7efb
    g7 = v9;
    *(int32_t *)(v8 + 8) = v9 + 320;
    int32_t v10 = g2; // 0x7f07
    int32_t v11 = *(int32_t *)(v10 + 64); // 0x7f07
    *(int32_t *)(v10 - 120) = 32;
    *(int32_t *)(g2 + 68 + 4 * v11) = *(int32_t *)(v6 + 52);
    int32_t * v12 = (int32_t *)(g2 + 64); // 0x7f15_0
    *v12 = *v12 + 1;
    int32_t v13 = g2; // 0x7f18
    int32_t v14 = v13 + 44; // bp-20
    *(int32_t *)v13 = 23;
    int32_t v15 = _qm_KerbComputeRequestBodyChecksum__YGJPAVCScratchMemoryAllocator__PAUKERB_KDC_REQUEST_BODY__PAUKERB_CHECKSUM___Z(v14, v13 - 124, (int32_t *)(v13 - 12), 0x10000); // 0x7f2b
    g6 = v15;
    int32_t v16 = g2; // 0x7faa
    if (v15 >= g5) {
        int32_t v17 = g7; // 0x7f3c
        int32_t v18 = *(int32_t *)(v17 + 356); // 0x7f3c
        _qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v16 + 44, v17 + 360, v18, 29, (int32_t *)(v16 + 40), v14);
        return;
    }
    int32_t * v19 = (int32_t *)(v16 + 64); // 0x7faa_0
    *v19 = *v19 - 1;
    int32_t v20 = *(int32_t *)(g2 + 68 + 4 * *(int32_t *)(g2 + 64)); // 0x7fb0
    char * v21 = (char *)v20;
    uint32_t v22 = *(int32_t *)(g2 + 52) - v20; // 0x7fb7
    memset(v21, 0, v22 / 4);
    memset(v21, 0, v22 % 4);
    int32_t v23;
    function_811f(v23);
}

// Address range: 0x7fe7 - 0x7fe8
void function_7fe7(void) {
    // 0x7fe7
    return;
}

// Address range: 0x7fe9 - 0x811e
int32_t function_7fe9(int32_t a1, int32_t a2, int32_t a3) {
    // 0x7fe9
    *(int32_t *)(g2 + 124) = g7;
    int32_t v1 = g2; // 0x7ff0
    int32_t v2; // 0x7ff0
    if (g6 == g5) {
        // 0x7ff0
        v2 = *(int32_t *)(v1 + 56);
        g6 = v2;
        // branch -> 0x7ff3
    } else {
        // 0x7fe9
        v2 = g6;
        // branch -> 0x7ff3
    }
    uint32_t v3 = g7; // 0x7ff3
    char * v4 = (char *)*(int32_t *)(v1 + 28);
    char * v5 = (char *)v2;
    memcpy(v5, v4, v3 / 4);
    memcpy(v5, v4, v3 % 4);
    int32_t * v6 = (int32_t *)(g2 + 64); // 0x8008_0
    *v6 = *v6 - 1;
    int32_t v7 = g2; // 0x800b
    int32_t v8 = *(int32_t *)(v7 + 68 + 4 * *(int32_t *)(v7 + 64)); // 0x800e
    g5 = v8;
    int32_t * v9 = (int32_t *)(v7 + 52); // 0x8012_0
    int32_t v10 = *v9 - v8; // 0x8015
    g7 = v10;
    *v9 = v8;
    memset((char *)g5, 0, v10 / 4);
    int32_t set_mem = (int32_t)memset((char *)g5, 0, g7 % 4);
    if (g6 != 0) {
        int32_t v11 = g2; // 0x802e
        int32_t v12 = *(int32_t *)(v11 + 124); // 0x802e
        int32_t * v13 = (int32_t *)(v11 + 52); // 0x8031_0
        g5 = *v13;
        *v13 = *v13 + (v12 + 3 & -4);
        int32_t v14 = g2; // 0x803d
        int32_t * v15 = (int32_t *)(v14 + 52); // 0x803d_0
        int32_t v16 = g5; // 0x8045
        int32_t v17 = v16; // 0x804f
        int32_t v18 = v14; // 0x804f
        if (*v15 > *(int32_t *)(v14 + 48)) {
            // 0x8045
            *v15 = v16;
            g5 = 0;
            v17 = 0;
            v18 = g2;
            // branch -> 0x804a
        }
        // 0x804a
        *(int32_t *)(v18 + 28) = v17;
        int32_t v19 = g6; // 0x8052
        g7 = v19;
        memcpy((char *)g5, (char *)v19, v12 / 4);
        set_mem = v12 % 4;
        // branch -> 0x805d
    }
    // 0x805d
    memcpy((char *)g5, (char *)g7, set_mem);
    *(int32_t *)(g2 + 16) = 0;
    char * v20 = (char *)(g2 - 140); // 0x8061_0
    *v20 = *v20 | -128;
    int32_t v21 = g2; // 0x8068
    *(int32_t *)(v21 - 128) = v21 + 16;
    int32_t v22 = g2; // 0x806e
    int32_t v23 = v22 + 44; // bp-12
    *(int32_t *)(v22 + 20) = 1;
    _qm_KerbAddPacRequestPreAuth__YGJPAVCScratchMemoryAllocator__HPAPAUKERB_KDC_REQUEST_preauth_data_s___Z(v23, 0, (int32_t *)(v22 - 128), 0);
    int32_t v24 = g2; // 0x808e
    int32_t v25 = *(int32_t *)(v24 - 48); // 0x8092
    _qm_KerbAddClientVersionPreAuth__YGJPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__KPAPAUKERB_KDC_REQUEST_preauth_data_s___Z(v24 + 44, v24, v25, v24 - 128, v23, 0);
    int32_t v26 = g2; // 0x80a8
    int32_t v27 = *(int32_t *)(v26 + 112); // 0x80b3
    int32_t v28 = v26 + 44; // 0x80b7
    if (_qm_KerbAddXboxServiceRequestPreAuth__YGJPAVCScratchMemoryAllocator__PBUKERB_ENCRYPTION_KEY__PBUXKERB_TGT_CONTEXT__KPBUXKERB_SERVICE_CONTEXT__PAPAUKERB_KDC_REQUEST_preauth_data_s___Z(v28, v26) < 0) {
        // 0x8104
        g6 = -0x3fffff66;
        int32_t v29;
        return function_811f(v29);
    }
    int32_t v30 = g2; // 0x80c4
    *(int32_t *)(v30 + 32) = *(int32_t *)*(int32_t *)(v30 + 120);
    int32_t v31 = g2; // 0x80cc
    *(int32_t *)(v31 + 36) = *(int32_t *)(v31 + 116);
    int32_t v32 = g2; // 0x80d2
    int32_t v33 = v32 + 44; // bp-72
    *(int32_t *)(v32 - 136) = 5;
    *(int32_t *)(g2 - 132) = 12;
    return _qm_KerbPackData__YGJPAVCScratchMemoryAllocator__PAXKPAKPAPAE_Z(v33, v32 - 140, 49, (int32_t *)(v32 + 32), (int32_t *)(v32 + 36), v28, v26, v27);
}

// Address range: 0x811f - 0x8130
int32_t function_811f(int32_t a1) {
    // 0x811f
    return g6;
}

// Address range: 0x8363 - 0x8380
int32_t _qm_XkerbBuildApRequest_CXo__IAEJPAUXKERB_SERVICE_CONTEXT__PAT_LARGE_INTEGER__PAEI2PAI_Z(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1;
    g2 = &v1;
    g7 = 0;
    function_8381(g5);
    return 2000;
}

// Address range: 0x8381 - 0x8473
void function_8381(int32_t a1) {
    int32_t v1 = g2; // 0x8381
    g6 = *(int32_t *)*(int32_t *)(v1 + 28);
    int32_t v2 = *(int32_t *)(v1 + 24); // ebx
    int32_t v3;
    int32_t v4 = &v3; // 0x8389_0
    int32_t v5;
    *(int32_t *)(v1 - 96) = (int32_t)&v5;
    *(int32_t *)(g2 - 100) = v4;
    *(int32_t *)(g2 - 84) = g7;
    *(int32_t *)(g2 - 92) = v4;
    *(int32_t *)(g2 - 80) = g7;
    memset((char *)&v3, v4, 500);
    *(int32_t *)(g2 - 88) = v2;
    if (v2 != g7) {
        // 0x83b0
        *(int32_t *)(g2 - 84) = g6;
        // branch -> 0x83b3
    }
    int32_t v6 = g2; // 0x83b3
    int32_t v7 = *(int32_t *)(v6 + 12); // bp-4
    *(int32_t *)(v6 - 44) = *(int32_t *)(v6 - 12);
    _qm_KerbGetCurrentTime__YGXPAT_LARGE_INTEGER___Z(v7, v3);
    int32_t v8 = g2; // 0x83c1
    int32_t v9 = *(int32_t *)(v8 + 8); // 0x83c1
    *(int32_t *)(v8 - 32) = v9 + 696;
    int32_t v10 = g2; // 0x83cd
    int32_t v11 = *(int32_t *)(v9 + 732); // 0x83d3
    int32_t v12 = v9 + 736; // 0x83d9
    int32_t v13 = v10 - 100; // bp-24
    *(int32_t *)(v10 - 40) = 23;
    *(int32_t *)(g2 - 36) = 16;
    if (_qm_KerbUnpackData__YGJPAVCScratchMemoryAllocator__PAEKKPAPAX_Z(v13, v12, v11, 29, (int32_t *)(v10 - 8), v7) == 0) {
        int32_t v14 = g2; // 0x83fb
        *(int32_t *)(v14 - 28) = 0;
        *(int32_t *)(v14 - 24) = 0;
        *(int32_t *)(v14 - 20) = 0;
        int32_t v15 = g2; // 0x8401
        g5 = *(int32_t *)(v15 + 28);
        *(int32_t *)(v15 - 20) = *(int32_t *)(v15 + 16);
        int32_t v16 = g2; // 0x840a
        *(int32_t *)(v16 - 24) = *(int32_t *)(v16 + 20);
        *(int32_t *)(g2 + 28) = *(int32_t *)g5;
        int32_t v17 = g2; // 0x8415
        int32_t v18 = v17 - 28; // 0x841f
        int32_t v19 = *(int32_t *)(v17 - 8); // 0x8428
        int32_t v20 = *(int32_t *)(v17 + 12); // 0x842e
        *(int32_t *)v18 = -131;
        int32_t v21 = g7; // 0x843b
        int32_t v22 = v21 + 584; // 0x8442
        g7 = v22;
        int32_t v23 = g2; // 0x8449
        *(int32_t *)(v23 - 16) = g3;
        int32_t v24 = v23 - 100; // 0x8450
        if (_qm_KerbCreateApRequest__YGJPAVCScratchMemoryAllocator__PAD1PBUKERB_ENCRYPTION_KEY__KPAT_LARGE_INTEGER__PBUKERB_TICKET__KPBUKERB_CHECKSUM__EPAKPAPAE_Z(v24, v22, v21 + 648, (int32_t *)(v17 - 40), 0, v20, (char *)v19, 0x20000000, v18, 0, v17 + 28, (int32_t *)(v17 - 16), v13, v12, v11) == 0) {
            // 0x8462
            *(int32_t *)g5 = *(int32_t *)(g2 + 28);
            // branch -> 0x8467
            // 0x8467
            return;
        }
    }
    // 0x8459
    *(int32_t *)(g2 - 4) = -0x3fffff66;
    // branch -> 0x8467
}

// --------------------- Meta-Information ---------------------

// Detected functions: 163
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2018-04-27 03:40:00
