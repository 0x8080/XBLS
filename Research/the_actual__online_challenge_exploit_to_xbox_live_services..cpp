#include "stdafx.h"

XEX_EXECUTION_ID xeExecutionId;
BYTE SignatureFinal[0x80];
#define SRAM 0x8000020000010000

DWORD ConvertHVAddressToSramAddressss(DWORD HvAddress) {
	return (HvAddress >> 6) & 0xFFFFFFFE;
}

DWORD ConvertChallengeAddressToHVAddress(DWORD Address) {
	return (((Address >> 16) & 0x3FFFF) | 0x8000000000000000);
}

BYTE SIGNATURE_PUB[0x90] = {
	0x00, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x04, 0xD0, 0x55, 0x50, 0x79, 0x19, 0x95, 0x27,
	0x78, 0x89, 0x97, 0x08, 0xDE, 0x24, 0xD1, 0xED, 0xB1, 0xEA, 0xE5, 0x48,
	0xAC, 0x1A, 0xC3, 0xC8, 0x29, 0x45, 0xB0, 0x16, 0x9B, 0xEF, 0x78, 0x8F,
	0xEF, 0x26, 0x9D, 0x54, 0x59, 0x95, 0x2D, 0x25, 0xA5, 0xAC, 0xA3, 0xA6,
	0x94, 0x45, 0xE5, 0x42, 0x2E, 0x39, 0x88, 0x0C, 0x3C, 0xAE, 0xEB, 0xFD,
	0x53, 0x3A, 0xE9, 0x70, 0x43, 0xEA, 0xD1, 0xD1, 0x78, 0xCE, 0xED, 0x1C,
	0xE5, 0xFD, 0x0F, 0x80, 0x94, 0x6F, 0x4F, 0xFF, 0xAD, 0x45, 0x88, 0xCF,
	0x22, 0x4C, 0x56, 0xDE, 0x03, 0xE2, 0x46, 0x2F, 0x19, 0xB8, 0x2C, 0xD0,
	0xD7, 0xE9, 0x64, 0xB2, 0x68, 0x0C, 0x40, 0xF5, 0x4F, 0xDA, 0x80, 0x8F,
	0x71, 0xA9, 0x64, 0xA4, 0x15, 0x53, 0x6E, 0x2B, 0x49, 0x44, 0x55, 0xCB,
	0x05, 0x17, 0x3F, 0x66, 0xE1, 0x32, 0x2F, 0x1D, 0xE9, 0x2A, 0xD6, 0x4B
};

PBYTE CalulateChecksum(PBYTE Data, DWORD cbData, PBYTE Checksum, DWORD cbChecksum) {
	int Increment = 0;

	for (auto s = 0; s < cbChecksum; s += 0x14) {
		int Subsize = (s + 0x14 > cbChecksum) ? cbChecksum - s : 0x14;
		BYTE Output[0x14];

		XECRYPT_SHA_STATE sha;
		XeCryptShaInit(&sha);
		XeCryptShaUpdate(&sha, Data, cbData);
		XeCryptShaUpdate(&sha, (PBYTE)&Increment, 4);
		XeCryptShaFinal(&sha, Output, 0x14);

		for (auto l = 0; l < Subsize; l++)
			Checksum[s + l] ^= Output[l];

		Increment += 1;
	}
	return Checksum;
}

VOID CreateSignature(PBYTE Signature, PBYTE Key, PBYTE Random) {
	BYTE ZeroSha[] = { 0xDA, 0x39, 0xA3, 0xEE, 0x5E, 0x6B, 0x4B, 0x0D, 0x32, 0x55, 0xBF, 0xEF, 0x95, 0x60, 0x18, 0x90, 0xAF, 0xD8, 0x07, 0x09 };

	Signature[0] = 0;

	memcpy((Signature + 1), Random, 0x14);
	memcpy((Signature + 0x15), ZeroSha, 0x14);
	memset((Signature + 0x29), 0, 0x1A);

	Signature[0x4F] = 1;
	memcpy((Signature + 0x50), Key, 0x30);

	memcpy(Signature + 0x15, CalulateChecksum(Random, 0x14, (Signature + 0x15), 0x6B), 0x14);
	memcpy(Signature + 0x1, CalulateChecksum(Signature + 0x15, 0x6B, Random, 0x14), 0x14);
}

VOID CalculateSignature(PBYTE Signature) {
	BYTE Random[0x14];
	XeCryptRandom(Random, 0x14);

	CreateSignature(Signature, reinterpret_cast<BYTE*>(HV::ProcessorKeys), Random);
	Utilities::Reverse(Signature, 0x80);

	XeCryptBnQw_SwapDwQwLeBe((PQWORD)Signature, (PQWORD)Signature, 0x10);
	XeCryptBnQwNeRsaPubCrypt((PQWORD)Signature, (PQWORD)Signature, (PXECRYPT_RSA)SIGNATURE_PUB);
	XeCryptBnQw_SwapDwQwLeBe((PQWORD)Signature, (PQWORD)Signature, 0x10);
}

VOID DumpFiles(PBYTE Salt, PBYTE Buffer) {
	CHAR KeyName[0x33];
	sprintf(KeyName, "%04X_%04X_%04X\0", *(PWORD)&HV::ProcessorKeys, *(PWORD)(&HV::ProcessorKeys + 0x10), *(PWORD)(&HV::ProcessorKeys + 0x20));

	CHAR dirchar[128];
	memset(dirchar, 0, 128);
	sprintf(dirchar, "LE:\\XeDumps\\%s", KeyName);
	CreateDirectory(dirchar, NULL);

	CHAR keydirchar[128];
	memset(keydirchar, 0, 128);
	sprintf(keydirchar, "LE:\\XeDumps\\%s\\Key.bin", KeyName);
	Utilities::CWriteFile(keydirchar, &HV::ProcessorKeys, 0x30);

	BYTE ECCSalt[0x2];
	HV::HvPeekBytes(0x800002000001F810, ECCSalt, 0x2);

	memset(dirchar, 0, 128);
	sprintf(dirchar, "LE:\\XeDumps\\%s\\Salts", KeyName);
	CreateDirectory(dirchar, NULL);

	BYTE PairData[0x40];
	memset(PairData, NULL, 0x40);

	// 0x50 hash for pair 0 - 0x14
	CopyMemory(PairData, Buffer + 0x50, 0x14);

	// hvexaddress for pair 0x20 - 0x22
	CopyMemory(PairData + 0x20, Buffer + 0xF8, 0x2);

	// ecc salt for pair 0x30 - 0x32
	CopyMemory(PairData + 0x30, ECCSalt, 0x2);

	CHAR filechar[0x100];
	memset(filechar, 0, 0x100);
	sprintf(filechar, "LE:\\XeDumps\\%s\\Salts\\%08X%08X%08X%08X.bin", KeyName, *(PDWORD)(Salt), *(PDWORD)(Salt + 0x4), *(PDWORD)(Salt + 0x8), *(PDWORD)(Salt + 0xC));
	Utilities::CWriteFile(filechar, PairData, sizeof(PairData));
}

//#define DUMPCHALLENGEDATA
BYTE Cache[0x1000];
DWORD System::XeKeysExecuteHook(PBYTE Buffer, DWORD dwFileSize, PBYTE HvSalt, void* arg2, void* arg3, void* arg4) {
#ifdef DUMPCHALLENGEDATA
	BYTE key[0x10] = { 0xDD, 0x88, 0xAD, 0x0C, 0x9E, 0xD6, 0x69, 0xE7, 0xB5, 0x67, 0x94, 0xFB, 0x68, 0x56, 0x3E, 0xFA };
	XECRYPT_RC4_STATE rc4;
	PBYTE decChalData = (PBYTE)XPhysicalAlloc(dwFileSize, MAXULONG_PTR, 0, PAGE_READWRITE);
	memcpy(decChalData, Buffer, dwFileSize);
	
	PBYTE rc4Key = (PBYTE)XPhysicalAlloc(0x10, MAXULONG_PTR, 0, PAGE_READWRITE);
	XeCryptHmacSha((PBYTE)key, 0x10, decChalData + 0x10, 0x10, 0, 0, 0, 0, rc4Key, 0x10);
	XeCryptRc4Key(&rc4, rc4Key, 0x10);
	XeCryptRc4Ecb(&rc4, decChalData + 0x20, dwFileSize - 0x20);

	Utilities::CWriteFile("LE:\\challengedec.bin", decChalData, dwFileSize);
	return ERROR_SUCCESS;
#endif
	
	HV::HvPeekBytes(0x8000010000000000, (HV::DirtyHv), 0xFFFF);
	HV::HvPeekBytes(0x8000010200010000, (HV::DirtyHv + 0x10000), 0xFFFF);
	HV::HvPeekBytes(0x8000010400020000, (HV::DirtyHv + 0x20000), 0xFFFF);
	HV::HvPeekBytes(0x8000010600030000, (HV::DirtyHv + 0x30000), 0xFFFF);

	memcpy(HV::CleanHV + 0x20, KV::ClientHvCpukey, 0x10);
	*(PDWORD)(HV::CleanHV + 0x14) = KV::UpdateSequence;
	*(PWORD)(HV::CleanHV + 0x06) = (KV::type1KV) ? 0xD81E : 0xD83E;
	*(PDWORD)(HV::CleanHV + 0x74) = KV::ConsoleType;

	if (!KV::CRL) 
		CalculateSignature(SignatureFinal);

	HV::HvPokeBytes(0x8000010000000000, HV::CleanHV, 0xFFFF);
	HV::HvPokeBytes(0x8000010000000000, HV::DirtyHv, 0x20);
	HV::HvPokeBytes(0x8000010000000020, KV::ClientHvCpukey, 0x10);
	HV::HvPokeBytes(0x8000010200010000, (HV::CleanHV + 0x10000), 0xFFFF);

	HV::HvPokeBytes(0x8000010200010000, (HV::DirtyHv + 0x10000), 0x04); 
	HV::HvPokeBytes(0x8000010200010020, (HV::DirtyHv + 0x10020), 0xA0); 
	HV::HvPokeBytes(0x8000010200010100, (HV::DirtyHv + 0x10100), 0x30); 
	HV::HvPokeBytes(0x8000010200016390, (HV::DirtyHv + 0x16390), 0x04); // updated
	HV::HvPokeBytes(0x8000010200016620, (HV::DirtyHv + 0x16620), 0x01); // updated
	HV::HvPokeBytes(0x8000010200016640, (HV::DirtyHv + 0x16640), 0x14); // updated

	HV::HvPokeBytes(0x8000010200016673, (HV::DirtyHv + 0x16673), 0x05); // updated

	HV::HvPokeBytes(0x8000010200016680, (HV::DirtyHv + 0x16680), 0x80); // updated

	HV::HvPokeBytes(0x8000010200016686, (HV::CleanHV + 0x16686), 0x02); // updated
	HV::HvPokeBytes(0x800001020001668E, (HV::CleanHV + 0x1668E), 0x03); // updated
	HV::HvPokeBytes(0x8000010200016695, (HV::CleanHV + 0x16695), 0x01); // updated
	HV::HvPokeBytes(0x80000102000166B6, (HV::CleanHV + 0x166B6), 0x01); // updated
	HV::HvPokeBytes(0x80000102000166BE, (HV::CleanHV + 0x166BE), 0x02); // updated
	HV::HvPokeBytes(0x80000102000166C6, (HV::CleanHV + 0x166C6), 0x03); // updated
	HV::HvPokeBytes(0x80000102000166CD, (HV::CleanHV + 0x166CD), 0x01); // updated
	HV::HvPokeBytes(0x80000102000166D4, (HV::CleanHV + 0x166D4), 0x04); // updated
	HV::HvPokeBytes(0x80000102000166ED, (HV::CleanHV + 0x166ED), 0x03); // updated

	HV::HvPokeBytes(0x8000010200016710, (HV::DirtyHv + 0x16710), 0x10); // updated
	HV::HvPokeBytes(0x8000010200016980, (HV::DirtyHv + 0x16980), 0x102); // updated

	HV::HvPokeBytes(0x80000102000169DE, (HV::CleanHV + 0x169DE), 0x01); // updated
	HV::HvPokeBytes(0x8000010200016A37, (HV::CleanHV + 0x16A37), 0x01); // updated

	HV::HvPokeBytes(0x8000010200016B90, (HV::DirtyHv + 0x16B90), 0x10); // updated
	HV::HvPokeBytes(0x8000010200016E98, (HV::DirtyHv + 0x16E98), 0x04); // updated

	HV::HvPokeBytes(0x8000010400020000, (HV::CleanHV + 0x20000), 0xFFFF);
	HV::HvPokeBytes(0x8000010600030000, (HV::CleanHV + 0x30000), 0xFFFF);

	/* BYTE ESalt[0x10];
	BYTE PLoad[0x600];

	memcpy(ESalt, HvSalt, 0x10);
	memcpy(PLoad, Buffer, 0x600);

	for(auto i = 0; i < 256; i++) {
		memcpy(HvSalt, Salts[i], 0x10);
		memcpy(Buffer, PLoad, 0x600);

		XeKeysExecute((PBYTE)Buffer, (DWORD)dwFileSize, (PBYTE)MmGetPhysicalAddress(HvSalt), (PXBOX_KRNL_VERSION)arg2, (PDWORD)arg3, (PDWORD)arg4);
		DumpFiles(HvSalt, Buffer);
	} 

	memcpy(HvSalt, ESalt, 0x10);
	memcpy(Buffer, PLoad, 0x600); */    

	// excute real challenge
	XeKeysExecute(Buffer, dwFileSize, (PBYTE)MmGetPhysicalAddress(HvSalt), arg2, arg3, arg4);

	// read cache in clean state
	//HV::HvPeekBytes(SRAM, Cache, sizeof(Cache));

	HV::HvPokeBytes(0x8000010000000000, HV::DirtyHv, 0xFFFF);
	HV::HvPokeBytes(0x8000010200010000, (HV::DirtyHv + 0x10000), 0xFFFF);
	HV::HvPokeBytes(0x8000010400020000, (HV::DirtyHv + 0x20000), 0xFFFF);
	HV::HvPokeBytes(0x8000010600030000,  (HV::DirtyHv + 0x30000), 0xFFFF);

	*(PWORD)(Buffer + 0x2E) = KV::type1KV ? 0xD81E : 0xD83E;
	*(PDWORD)(Buffer + 0x34) = KV::UpdateSequence;
	*(PDWORD)(Buffer + 0x38) = HV::SpoofHvStatusFlag();
	*(PDWORD)(Buffer + 0x3C) = KV::ConsoleType;
	memcpy(Buffer + 0x64, KV::CPUDigest, 0x14);
	memcpy(Buffer + 0x78, SignatureFinal, 0x80);

	if (!KV::CRL) {
		Utilities::XNotifyUI("LEOffline - Fully Stealthed!");
		KV::CRL = TRUE;
		//Utilities::CWriteFile("LE:\\F0Cache.bin", Cache, sizeof(Cache));
	}
	//HalReturnToFirmware(HalFatalErrorRebootRoutine);
	return ERROR_SUCCESS;
}

//#define DEBUGXOSC
BYTE bDashboardHash[0x4DEC];
bool DumpedForboot = false;
VOID CalculateZeroSixtyToBuffer(PBYTE Buffer) {
	BYTE unknownBuffer[0x10];
	BYTE ZeroXSixtyHash[0x14];

	memcpy(ZeroXSixtyHash,(PDWORD)0x8E03AA40, 0x14);
	unknownBuffer[0xE] &= 0xF8;

	DWORD XoscAddr = (DWORD)Utilities::ResolveFunction(MODULE_XOSC, 1);
	DWORD HashAddr = 0x90010000 | *(PWORD)(XoscAddr - 0x62);
	DWORD HashSelfngth = *(PWORD)(XoscAddr - 0x66);

	PLDR_DATA_TABLE_ENTRY hCurrTitle = (PLDR_DATA_TABLE_ENTRY)GetModuleHandleA(0);
#ifdef DEBUGXOSC

	PLDR_DATA_TABLE_ENTRY hXam = (PLDR_DATA_TABLE_ENTRY)GetModuleHandleA(MODULE_XAM);
	PLDR_DATA_TABLE_ENTRY hKernel = (PLDR_DATA_TABLE_ENTRY)GetModuleHandleA(MODULE_KERNEL);

	IMAGE_XEX_HEADER* xamHeader = (IMAGE_XEX_HEADER*)(hXam->XexHeaderBase);
	IMAGE_XEX_HEADER* krnlHeader = (IMAGE_XEX_HEADER*)(hKernel->XexHeaderBase);

	if (xamHeader) {
		XEX_SECURITY_INFO* securityInfo = (XEX_SECURITY_INFO*)(xamHeader->SecurityInfo);
		int size = ((xamHeader->SizeOfHeaders - ((int)xamHeader->SecurityInfo + 0x17C)) + (int)xamHeader);
	    Utilities::CWriteFile("LE:\\XamHeader.bin", &securityInfo->AllowedMediaTypes, size);
	}

	if (krnlHeader) {
		XEX_SECURITY_INFO* securityInfo = (XEX_SECURITY_INFO*)(krnlHeader->SecurityInfo);
		int size = ((krnlHeader->SizeOfHeaders - ((int)krnlHeader->SecurityInfo + 0x17C)) + (int)krnlHeader);
		Utilities::CWriteFile("LE:\\KrnHeader.bin", &securityInfo->AllowedMediaTypes, size);
	}
#endif

	IMAGE_XEX_HEADER* currModuleHeader = (IMAGE_XEX_HEADER*)(hCurrTitle->XexHeaderBase);
	XEX_SECURITY_INFO* securityInfo = (XEX_SECURITY_INFO*)(currModuleHeader->SecurityInfo);
	int Size = ((currModuleHeader->SizeOfHeaders - (DWORD)&securityInfo->AllowedMediaTypes) + (int)currModuleHeader);
	if (Utilities::IsBufferEmpty(bDashboardHash, 0x4DEC) /*&& strcmp((PCHAR)0x92020480, "2.0.17559.0") == NULL */) {
		if (Size != 0x4DEC)
			HalReturnToFirmware(HalResetSMCRoutine);
		memcpy(bDashboardHash, (PBYTE)&securityInfo->AllowedMediaTypes, Size);
	}
	else if (Utilities::IsBufferEmpty(bDashboardHash, 0x4DEC))
		HalReturnToFirmware(HalResetSMCRoutine);

#ifdef DEBUGXOSC
	if (!DumpedForboot) {
		Utilities::CWriteFile("LE:\\CurModuleHeader.bin", bDashboardHash, sizeof(bDashboardHash));
		DumpedForboot = true;
	}
#endif

	XeCryptSha((PBYTE)XOSC::XamData, 0x2D94, ZeroXSixtyHash, 0x14, unknownBuffer, 0x10, ZeroXSixtyHash, 0x14);
	XeCryptSha((PBYTE)XOSC::KrnData, 0x20, ZeroXSixtyHash, 0x14, KV::sMacAddress, 0x06, ZeroXSixtyHash, 0x14);
	XeCryptSha((PBYTE)bDashboardHash, 0x4DEC, ZeroXSixtyHash, 0x14, KV::SmcVersion, 0x5, ZeroXSixtyHash, 0x14);

	XeCryptSha((PBYTE)HashAddr, HashSelfngth, ZeroXSixtyHash, 0x14, 0, 0, ZeroXSixtyHash, 0x14);
	ZeroXSixtyHash[0] = 07;
	memcpy(Buffer + 0x60, ZeroXSixtyHash, 0x10); 
}

DWORD GetStorageDeviceSize(PCHAR path) {
	int* outSize = 0;
	HANDLE file = 0;
	NTSTATUS status = STATUS_SUCCESS;

	ANSI_STRING deviceName = { 0 };
	OBJECT_ATTRIBUTES objAttr = { 0 };
	IO_STATUS_BLOCK statusBlock = { 0 };
	FILE_FS_SIZE_INFORMATION sizeInfo = { 0 };

	RtlInitAnsiString(&deviceName, path);
	InitializeObjectAttributes(&objAttr, &deviceName, OBJ_CASE_INSENSITIVE, 0);

	if (NT_SUCCESS(NtOpenFile(&file, (SYNCHRONIZE | 1), &objAttr, &statusBlock, FILE_SHARE_READ, FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | 0x800000))) {
		if (NT_SUCCESS(status = NtQueryVolumeInformationFile(file, &statusBlock, &sizeInfo, 0x18, FileFsSizeInformation)))
			*outSize = sizeInfo.TotalAllocationUnits.LowPart;
	}

	NtClose(file);
	return status;
}

DWORD DumpXoscModule(void* Image, DWORD ImageSize, CONST PCHAR ImageName, DWORD LoadFlags, DWORD Version, HMODULE* ModuleHandle) {

	CHAR buffer[0x19];
	DWORD far noBytesRead;

	sprintf(buffer, "LE:\\%s", ImageName);
	HANDLE hXoscModule = CreateFile(buffer, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	WriteFile(hXoscModule, Image, ImageSize, &noBytesRead, NULL);
	CloseHandle(hXoscModule);
	*ModuleHandle = static_cast<HMODULE>(Main::hSelf);
	return ERROR_SUCCESS;
}

DWORD System::XSC_XnpLogonSetChallengeResponseHook(DWORD Task, PBYTE Buffer, DWORD BufferSize) {
	/* DWORD memoryUnit0 = GetStorageDeviceSize("\\Device\\Mu0\\");
	DWORD memoryUnit1 = GetStorageDeviceSize("\\Device\\Mu1\\");
	DWORD memoryUnitintFlash = GetStorageDeviceSize("\\Device\\BuiltInMuSfc\\");
	DWORD memoryUnitintUSB = GetStorageDeviceSize("\\Device\\BuiltInMuUsb\\Storage\\");
	DWORD mass0PartitionFileSize = GetStorageDeviceSize("\\Device\\Mass0PartitionFile\\Storage\\");
	DWORD mass1PartitionFileSize = GetStorageDeviceSize("\\Device\\Mass1PartitionFile\\Storage\\");
	DWORD mass2PartitionFileSize = GetStorageDeviceSize("\\Device\\Mass2PartitionFile\\Storage\\"); */

	*(PQWORD)(Buffer + 0x8) = (0x1BD + (KV::type1KV ? 0 : 2));

	memcpy(Buffer + 0x38, &xeExecutionId, 0x18);
	*(PDWORD)(Buffer + 0x44) = 0xFFFE07D1;
	memcpy(Buffer + 0x50, KV::CPUDigest, 0x10);
	CalculateZeroSixtyToBuffer(Buffer);
	memcpy(Buffer + 0x70, KV::SMCHash, 0x10);

	memcpy(Buffer + 0x80, (&KV::KeyVault.XeikaCertificate.Data.OddData.PhaseLevel), 0x4);
	memset(Buffer + 0x84, 0, 0x4);
	*(PDWORD)(Buffer + 0x88) = 0xFFFE07D1;
	memcpy(Buffer + 0xF0, &KV::KeyVault.XeikaCertificate.Data.OddData.InquiryData, 0x24);
	memcpy(Buffer + 0x114, &KV::KeyVault.XeikaCertificate.Data.OddData.InquiryData, 0x24);

	memcpy(Buffer + 0x138, &KV::KeyVault.ConsoleSerialNumber, 0xC);
	memset(Buffer + 0x144, 0, 0x2);
	*(PSHORT)(Buffer + 0x146) = KV::type1KV ? 0xD81E : 0xD83E;
	memcpy(Buffer + 0x148, &KV::KeyVault.GameRegion, 0x2);
	memcpy(Buffer + 0x14A, &KV::KeyVault.OddFeatures, 0x2);
	memcpy(Buffer + 0x150, &KV::KeyVault.PolicyFlashSize, 0x4);
	*(PDWORD)(Buffer + 0x158) = HV::SpoofHvStatusFlag();

	*(PQWORD)(Buffer + 0x170) = KV::RevisionID;
	*(PDWORD)(Buffer + 0x1D0) = KV::HardwareID;
	memcpy(Buffer + 0x1A0, &KV::KeyVault.ConsoleCertificate.ConsoleId, 0x5);

	/* *(PDWORD)(Buffer + 0x2A8) = memoryUnit0;
	*(PDWORD)(Buffer + 0x2AC) = memoryUnit1;
	*(PDWORD)(Buffer + 0x2B0) = memoryUnitintFlash;
	*(PDWORD)(Buffer + 0x2B4) = memoryUnitintUSB;
	*(PDWORD)(Buffer + 0x2B8) = mass0PartitionFileSize;
	*(PDWORD)(Buffer + 0x2BC) = mass1PartitionFileSize;
	*(PDWORD)(Buffer + 0x2C0) = mass2PartitionFileSize; */
	//Utilities::CWriteFile("LE:\\XSC.bin", Buffer, 0x2E0);
	return ERROR_SUCCESS;
}

void* System::RtlImageXexHeaderFieldHook(void* headerBase, DWORD imageKey) {
	void* retVal = RtlImageXexHeaderField(headerBase, imageKey);
	if (imageKey == 0x40006 && retVal) {
		switch (((XEX_EXECUTION_ID*)retVal)->TitleID) {
		case 0xFFFF0055:
		case 0xC0DE9999:
		case 0xFFFE07FF:
		case 0xF5D20000:
		case 0xFFFF011D: {
			memcpy(retVal, &xeExecutionId, sizeof(XEX_EXECUTION_ID));
			break;
		}
	  }
	}
	else if (imageKey == 0x40006 && !retVal) 
		retVal = &xeExecutionId;
	return retVal;
}

DWORD System::InstalizeHooks() {
	*reinterpret_cast<PDWORD>(0x81A3CD60) = 0x38600001; // Gold Spoofing
	*reinterpret_cast<PDWORD>(0x81682544) = 0x60000000; // EvaulateContent
	*reinterpret_cast<PDWORD>(0x8167F978) = 0x38600000; // ContentEvaluateLicense
	*reinterpret_cast<PDWORD>(0x816798EC) = 0x60000000; // MmGetPhysicalAddress
	*reinterpret_cast<PDWORD>(0x8167C4B4) = 0x38600000; // XeKeysVerifyRSASignature

	DWORD Ver = ((XboxKrnlVersion->Major & 0xF) << 28) | ((XboxKrnlVersion->Minor & 0xF) << 24) | (XboxKrnlVersion->Build << 8) | (XboxKrnlVersion->Qfe);
	ZeroMemory(&xeExecutionId, sizeof(XEX_EXECUTION_ID));
	xeExecutionId.Version = Ver;
	xeExecutionId.BaseVersion = Ver;
	xeExecutionId.TitleID = 0xFFFE07D1;

	if (Utilities::PatchModuleImport(MODULE_XAM, MODULE_KERNEL, 0x12B, (DWORD)RtlImageXexHeaderFieldHook) != ERROR_SUCCESS) 
		return E_FAIL;
	if (Utilities::PatchModuleImport(MODULE_XAM, MODULE_KERNEL, 0x25F, (DWORD)System::XeKeysExecuteHook) != ERROR_SUCCESS)
		return E_FAIL;
	Utilities::PatchInJump((DWORD*)0x81857DA0, (DWORD)XSC_XnpLogonSetChallengeResponseHook, FALSE);
	//if (Utilities::PatchModuleImport(MODULE_XAM, MODULE_KERNEL, 0x19A, (DWORD)DumpXoscModule) != S_OK) return E_FAIL;
	return ERROR_SUCCESS;
}